#!/usr/bin/env bash
# Generated by build.sh on Sat Aug 16 12:23:34 PM MDT 2025
# Auto-assembled from numbered modules: 01_header.sh 02_colors.sh 03_helpers.sh 04_literals.sh 05_validators.sh 06_formatters.sh 07_commands.sh 08_interface.sh 09_footer.sh
# === 01_header.sh ===
#!/usr/bin/env bash
# watchdom - registry WHOIS watcher with phase-aware polling
# version: 2.1.0-bashfx-fixed
# portable: whois, date, grep, sed
# builtins: printf, read, local, declare, case, if, for, while

################################################################################
# readonly
################################################################################
readonly SELF_NAME="watchdom";
readonly SELF_VERSION="2.1.0-bashfx-fixed";
readonly SELF_PATH="$(realpath "${BASH_SOURCE[0]}")";
readonly SELF_DIR="$(dirname "$SELF_PATH")";
readonly WATCHDOM_RC="$HOME/.watchdomrc";

# XDG+ compliant paths for BashFX framework
readonly XDG_HOME="${HOME}/.local";
readonly XDG_LIB="${XDG_HOME}/lib";
readonly XDG_BIN="${XDG_HOME}/bin";
readonly XDG_ETC="${XDG_HOME}/etc";
readonly XDG_TMP="${HOME}/.cache/tmp";

# BashFX namespace paths (first-party code goes in /fx/)
readonly FX_LIB_DIR="${XDG_LIB}/fx";
readonly FX_BIN_DIR="${XDG_BIN}/fx";
readonly FX_INSTALL_PATH="${FX_LIB_DIR}/${SELF_NAME}";
readonly FX_BIN_LINK="${FX_BIN_DIR}/${SELF_NAME}";

# Rate limiting and error patterns
readonly RATE_LIMIT_PATTERN="rate limit|exceeded|too many|try again|access denied|quota";

################################################################################
# config
################################################################################
# Default settings (overridable by environment) - DEBUG ON for development
DEFAULT_INTERVAL="${WATCHDOM_INTERVAL:-60}";
DEFAULT_MAX_CHECKS="${WATCHDOM_MAX_CHECKS:-0}";
DEFAULT_TIME_LOCAL="${WATCHDOM_TIME_LOCAL:-1}";
DEFAULT_DEBUG="${WATCHDOM_DEBUG:-1}";  # Debug ON by default for development

# Email notification settings (all must be set to enable notifications)
NOTIFY_EMAIL="${NOTIFY_EMAIL:-}";           # Recipient email
NOTIFY_FROM="${NOTIFY_FROM:-}";             # Sender email  
NOTIFY_SMTP_HOST="${NOTIFY_SMTP_HOST:-}";   # SMTP server
NOTIFY_SMTP_PORT="${NOTIFY_SMTP_PORT:-}";   # SMTP port
NOTIFY_SMTP_USER="${NOTIFY_SMTP_USER:-}";   # SMTP username
NOTIFY_SMTP_PASS="${NOTIFY_SMTP_PASS:-}";   # SMTP password

# Phase timing thresholds (in seconds)
readonly HEAT_THRESHOLD=1800;    # 30 minutes - switch to HEAT phase
readonly GRACE_THRESHOLD=10800;  # 3 hours - switch to COOL phase

# TLD Registry defaults (can be extended via ~/.watchdomrc)
declare -A TLD_REGISTRY=(
    [".com"]="whois.verisign-grs.com|No match for"
    [".net"]="whois.verisign-grs.com|No match for"
    [".org"]="whois.pir.org|NOT FOUND"
    [".info"]="whois.afilias.net|Not found"
    [".biz"]="whois.nic.biz|Not found"
);

# === 02_colors.sh ===
################################################################################
# escape sequences (BashFX standard from esc.sh.*)
################################################################################
readonly red=$'\x1B[38;5;9m';
readonly green=$'\x1B[32m';
readonly blue=$'\x1B[38;5;39m';
readonly yellow=$'\x1B[33m';
readonly purple=$'\x1B[38;5;213m';
readonly cyan=$'\x1B[38;5;14m';
readonly grey=$'\x1B[38;5;249m';
readonly red2=$'\x1B[38;5;196m';
readonly white=$'\x1B[38;5;15m';
readonly x=$'\x1B[38;5;244m';

################################################################################
# glyphs (phase indicators and symbols)
################################################################################
readonly lambda=$'\xCE\xBB'              # Î» - POLL phase
readonly triangle=$'\xe2\x96\xb2'        # â–² - HEAT phase  
readonly triangle_up=$'\xe2\x96\xb5'     # â–µ - GRACE phase
readonly snowflake=$'\xe2\x9d\x85'       # â… - COOL phase
readonly pass=$'\xe2\x9c\x93'            # âœ“ - success
readonly fail=$'\xe2\x9c\x97'            # âœ— - failure
readonly delta=$'\xe2\x96\xb3'           # â–³ - warning/change
readonly spark=$'\xe2\x9c\xa8'           # âœ¨ - completion

################################################################################
# phase color mapping
################################################################################
_get_phase_color() {
    local phase="$1";
    case "$phase" in
        (POLL)  echo "$blue" ;;
        (HEAT)  echo "$red" ;;
        (GRACE) echo "$purple" ;;
        (COOL)  echo "$cyan" ;;
        (*)     echo "$grey" ;;
    esac
}

_get_phase_glyph() {
    local phase="$1";
    case "$phase" in
        (POLL)  echo "$lambda" ;;
        (HEAT)  echo "$triangle" ;;
        (GRACE) echo "$triangle_up" ;;
        (COOL)  echo "$snowflake" ;;
        (*)     echo "?" ;;
    esac
}
# === 03_helpers.sh ===
################################################################################
# simple stderr (BashFX compliant logging)
################################################################################
info()  { [[ ${opt_debug:-$DEFAULT_DEBUG} -eq 1 ]] && printf "%s[%s]%s %s\n" "$blue" "$(date +%H:%M:%S)" "$x" "$*" >&2; }
okay()  { [[ ${opt_debug:-$DEFAULT_DEBUG} -eq 1 ]] && printf "%s%s%s %s\n" "$green" "$pass" "$x" "$*" >&2; }
warn()  { [[ ${opt_debug:-$DEFAULT_DEBUG} -eq 1 ]] && printf "%s%s%s %s\n" "$yellow" "$delta" "$x" "$*" >&2; }
error() { printf "%s%s%s %s\n" "$red" "$fail" "$x" "$*" >&2; }
fatal() { printf "%s%s%s %s\n" "$red2" "$fail" "$x" "$*" >&2; exit 1; }
trace() { [[ ${opt_trace:-0} -eq 1 ]] && printf "%s[%s]%s %s\n" "$grey" "$(date +%H:%M:%S)" "$x" "$*" >&2; }

################################################################################
# utility helpers
################################################################################
_human_time() {
    local s=$1 d h m;
    ((d=s/86400, s%=86400, h=s/3600, s%=3600, m=s/60, s%=60));
    local out="";
    [[ $d -gt 0 ]] && out+="${d}d ";
    [[ $h -gt 0 ]] && out+="${h}h ";
    [[ $m -gt 0 ]] && out+="${m}m ";
    out+="${s}s";
    echo "$out";
}

_format_timer() {
    local seconds="$1";
    
    if [[ $seconds -lt 60 ]]; then
        # Use "30s" format for seconds only
        echo "${seconds}s";
    elif [[ $seconds -lt 3600 ]]; then
        # Use "5:30" format for minutes:seconds
        printf "%d:%02d" $((seconds/60)) $((seconds%60));
    elif [[ $seconds -lt 86400 ]]; then
        # Use "1:30:27" format for hours:minutes:seconds
        printf "%d:%02d:%02d" $((seconds/3600)) $(((seconds%3600)/60)) $((seconds%60));
    else
        # Use "2d 1:30:27" format for days + time
        local days=$((seconds/86400));
        local remaining=$((seconds%86400));
        printf "%dd %d:%02d:%02d" $days $((remaining/3600)) $(((remaining%3600)/60)) $((remaining%60));
    fi;
}

_format_target_time() {
    local seconds="$1";
    local sign="";
    
    # Handle negative time (past target)
    if [[ $seconds -lt 0 ]]; then
        sign="-";
        seconds=$((seconds * -1));
    fi;
    
    # Use same format as timer but with sign
    echo "${sign}$(_format_timer "$seconds")";
}

_format_completion_time() {
    local epoch="$1";
    # 12h format with am/pm lowercase
    date -d "@$epoch" "+%-I:%M:%S %P" 2>/dev/null || date -r "$epoch" "+%-I:%M:%S %P";
}

_cleanup() {
    local grace_files;
    grace_files=$(find /tmp -name ".watchdom_grace_*_$$" 2>/dev/null || true);
    if [[ -n "$grace_files" ]]; then
        rm -f $grace_files 2>/dev/null || true;
    fi;
    printf "\n" >&2;
    info "Monitoring stopped";
    exit 130;
}

# === 04_literals.sh ===
################################################################################
# literals (__*) - atomic operations (PHASE 1 CRITICAL FIXES)
################################################################################

################################################################################
# __parse_epoch - FIX: Returns empty epochs
################################################################################
__parse_epoch() {
    local when="$1";
    local epoch="";
    
    # If already epoch, return it
    if [[ "$when" =~ ^[0-9]+$ ]]; then
        echo "$when";
        return 0;
    fi
    
    # Try GNU date first (most common)
    if epoch=$(date -u -d "$when" +%s 2>/dev/null); then
        echo "$epoch";
        return 0;
    fi
    
    # Try BSD date (macOS)
    if epoch=$(date -u -j -f "%Y-%m-%d %H:%M:%S" "$when" +%s 2>/dev/null); then
        echo "$epoch";
        return 0;
    fi
    
    # Try gdate (macOS with GNU coreutils)
    if command -v gdate >/dev/null 2>&1; then
        if epoch=$(gdate -u -d "$when" +%s 2>/dev/null); then
            echo "$epoch";
            return 0;
        fi
    fi
    
    # Last resort: try common format variations
    local formatted_when;
    # Handle common input variations
    formatted_when=$(echo "$when" | sed 's/UTC$//' | sed 's/  */ /g' | sed 's/^ *//' | sed 's/ *$//');
    
    if epoch=$(date -u -d "$formatted_when UTC" +%s 2>/dev/null); then
        echo "$epoch";
        return 0;
    fi
    
    error "Cannot parse datetime: %s" "$when";
    return 1;
}

################################################################################
# __whois_query - FIX: No domain status extraction
################################################################################
__whois_query() {
    local domain="$1";
    local whois_output="";
    local ret=0;
    
    # Check if whois command exists
    if ! command -v whois >/dev/null 2>&1; then
        error "Required command 'whois' not found"
        return 3;
    fi
    
    trace "Executing WHOIS query for %s" "$domain"
    
    # Execute whois with timeout and error handling
    if ! whois_output=$(timeout 30 whois "$domain" 2>/dev/null); then
        error "WHOIS query failed for %s (timeout or network error)" "$domain"
        return 1;
    fi
    
    # Check for empty output
    if [[ -z "$whois_output" ]]; then
        error "WHOIS query returned empty result for %s" "$domain"
        return 1;
    fi
    
    # Check for rate limiting
    if echo "$whois_output" | grep -Eqi "$RATE_LIMIT_PATTERN"; then
        error "Rate limited by WHOIS server for %s" "$domain"
        return 2;
    fi
    
    trace "WHOIS query completed successfully for %s" "$domain"
    echo "$whois_output"
    return 0;
}

################################################################################
# __extract_domain_status - FIX: Missing lifecycle info
################################################################################
__extract_domain_status() {
    local whois_output="$1";
    local status="UNKNOWN";
    
    # Check for availability patterns (most specific first)
    if echo "$whois_output" | grep -qi "no match for\|not found\|no entries found\|available"; then
        status="AVAILABLE";
    elif echo "$whois_output" | grep -qi "pending.*delete\|pendingdelete"; then
        status="PENDING-DELETE";
    elif echo "$whois_output" | grep -qi "client.*hold\|server.*hold"; then
        status="ON-HOLD";
    elif echo "$whois_output" | grep -qi "redemption.*period\|rgp"; then
        status="REDEMPTION";
    elif echo "$whois_output" | grep -qi "domain.*name.*server\|name.*server"; then
        status="REGISTERED";
    elif echo "$whois_output" | grep -qi "reserved\|premium"; then
        status="RESERVED";
    fi
    
    echo "$status"
}

################################################################################
# __extract_registrar - Extract registrar information
################################################################################
__extract_registrar() {
    local whois_output="$1";
    local registrar="UNKNOWN";
    
    # Try to extract registrar name
    if registrar=$(echo "$whois_output" | grep -i "registrar:" | head -1 | sed 's/.*registrar: *//i' | sed 's/ *$//' | tr -d '\r'); then
        [[ -n "$registrar" ]] && echo "$registrar" && return 0
    fi
    
    # Try alternative patterns
    if registrar=$(echo "$whois_output" | grep -i "sponsoring registrar:" | head -1 | sed 's/.*sponsoring registrar: *//i' | sed 's/ *$//' | tr -d '\r'); then
        [[ -n "$registrar" ]] && echo "$registrar" && return 0
    fi
    
    # Default patterns for major registries
    if echo "$whois_output" | grep -qi "verisign"; then
        echo "VERISIGN"
    elif echo "$whois_output" | grep -qi "godaddy"; then
        echo "GODADDY"
    elif echo "$whois_output" | grep -qi "namecheap"; then
        echo "NAMECHEAP"
    else
        echo "UNKNOWN"
    fi
}

################################################################################
# __get_current_epoch - Current time as epoch
################################################################################
__get_current_epoch() {
    date +%s
}

################################################################################
# __format_time_display - Format time for display
################################################################################
__format_time_display() {
    local epoch="$1";
    local use_utc="${2:-0}";
    
    if [[ "$use_utc" -eq 1 ]]; then
        date -u -d "@$epoch" "+%a %b %d %H:%M:%S UTC %Y" 2>/dev/null || date -u -r "$epoch" "+%a %b %d %H:%M:%S UTC %Y"
    else
        date -d "@$epoch" "+%a %b %d %H:%M:%S %Z %Y" 2>/dev/null || date -r "$epoch" "+%a %b %d %H:%M:%S %Z %Y"
    fi
}
# === 05_validators.sh ===
################################################################################
# validators (_*) - input validation and state checking
################################################################################

################################################################################
# _validate_domain - Domain format validation
################################################################################
_validate_domain() {
    local domain="$1";
    
    # Check basic format
    if [[ ! "$domain" =~ ^[a-zA-Z0-9][a-zA-Z0-9.-]*[a-zA-Z0-9]\.[a-zA-Z]{2,}$ ]]; then
        error "Invalid domain format: %s" "$domain";
        return 1;
    fi;
    
    # Check length limits
    if [[ ${#domain} -gt 253 ]]; then
        error "Domain name too long: %s" "$domain";
        return 1;
    fi;
    
    # Check for double dots or invalid characters
    if [[ "$domain" =~ \.\. ]] || [[ "$domain" =~ ^[.-] ]] || [[ "$domain" =~ [.-]$ ]]; then
        error "Invalid domain format: %s" "$domain";
        return 1;
    fi;
    
    trace "Domain validation passed: %s" "$domain";
    return 0;
}

################################################################################
# _validate_datetime - Date string validation
################################################################################
_validate_datetime() {
    local when="$1";
    local epoch="";
    
    # Try to parse - if it works, it's valid
    if epoch=$(__parse_epoch "$when"); then
        trace "Datetime validation passed: %s -> %s" "$when" "$epoch";
        return 0;
    else
        error "Invalid datetime format: %s" "$when";
        return 1;
    fi;
}

################################################################################
# _validate_interval - Polling interval validation
################################################################################
_validate_interval() {
    local interval="$1";
    
    # Check if numeric
    if [[ ! "$interval" =~ ^[0-9]+$ ]]; then
        error "Interval must be numeric: %s" "$interval";
        return 1;
    fi;
    
    # Check minimum (warn for aggressive polling)
    if [[ "$interval" -lt 10 ]]; then
        warn "Interval %ss may trigger rate limits from WHOIS servers" "$interval";
    fi;
    
    # Check maximum (sanity check)
    if [[ "$interval" -gt 86400 ]]; then
        warn "Interval %ss is longer than 24 hours" "$interval";
    fi;
    
    trace "Interval validation passed: %ss" "$interval";
    return 0;
}

################################################################################
# _check_dependencies - Required command validation
################################################################################
_check_dependencies() {
    local missing=0;
    
    # Check for whois
    if ! command -v whois >/dev/null 2>&1; then
        error "Required command 'whois' not found";
        info "Install with: apt-get install whois (Ubuntu/Debian) or brew install whois (macOS)";
        missing=1;
    fi;
    
    # Check for date command
    if ! command -v date >/dev/null 2>&1; then
        error "Required command 'date' not found";
        missing=1;
    fi;
    
    # Check for timeout command (optional but recommended)
    if ! command -v timeout >/dev/null 2>&1; then
        warn "Command 'timeout' not found - WHOIS queries may hang";
    fi;
    
    if [[ "$missing" -eq 1 ]]; then
        return 1;
    fi;
    
    trace "All dependencies satisfied";
    return 0;
}

################################################################################
# _is_tld_supported - Check if TLD has configuration
################################################################################
_is_tld_supported() {
    local domain="$1";
    local tld="";
    
    # Extract TLD
    tld=$(echo "$domain" | grep -o '\.[^.]*$');
    
    # Check in built-in registry
    if [[ -n "${TLD_REGISTRY[$tld]:-}" ]]; then
        trace "TLD %s supported (built-in)" "$tld";
        return 0;
    fi;
    
    # Check in user config if it exists
    if [[ -f "$WATCHDOM_RC" ]] && grep -q "^$tld|" "$WATCHDOM_RC" 2>/dev/null; then
        trace "TLD %s supported (user config)" "$tld";
        return 0;
    fi;
    
    warn "TLD %s not configured - using generic WHOIS" "$tld";
    return 1;
}

################################################################################
# _load_tld_config - Load TLD configuration from user file
################################################################################
_load_tld_config() {
    local tld_file="$WATCHDOM_RC";
    local line tld server pattern;
    
    [[ ! -f "$tld_file" ]] && return 0;
    
    trace "Loading TLD configuration from %s" "$tld_file";
    
    while IFS='|' read -r tld server pattern; do
        # Skip comments and empty lines
        [[ "$tld" =~ ^#.*$ ]] || [[ -z "$tld" ]] && continue;
        
        # Validate format
        if [[ -n "$tld" && -n "$server" && -n "$pattern" ]]; then
            TLD_REGISTRY["$tld"]="$server|$pattern";
            trace "Loaded TLD config: %s -> %s | %s" "$tld" "$server" "$pattern";
        fi;
    done < "$tld_file";
    
    return 0;
}

################################################################################
# _get_tld_config - Get WHOIS server and pattern for TLD
################################################################################
_get_tld_config() {
    local domain="$1";
    local tld server pattern;
    
    # Extract TLD
    tld=$(echo "$domain" | grep -o '\.[^.]*$');
    
    # Look up in registry
    local config="${TLD_REGISTRY[$tld]:-}";
    
    if [[ -n "$config" ]]; then
        server=$(echo "$config" | cut -d'|' -f1);
        pattern=$(echo "$config" | cut -d'|' -f2);
        echo "$server|$pattern";
        return 0;
    fi;
    
    # Fallback to generic
    echo "|available";
    return 1;
}

# === 06_formatters.sh ===
################################################################################
# formatters (_*) - visual display and status line formatting
################################################################################

################################################################################
# _determine_phase - Calculate current polling phase
################################################################################
_determine_phase() {
    local target_epoch="$1";
    local current_epoch="$2";
    local time_diff=$((target_epoch - current_epoch));
    
    # No target set = POLL phase
    if [[ "$target_epoch" -eq 0 ]]; then
        echo "POLL";
        return 0;
    fi;
    
    # Before target
    if [[ $time_diff -gt $HEAT_THRESHOLD ]]; then
        echo "POLL";  # More than 30 minutes = normal polling
    elif [[ $time_diff -gt 0 ]]; then
        echo "HEAT";  # Approaching target = aggressive polling
    elif [[ $((current_epoch - target_epoch)) -lt $GRACE_THRESHOLD ]]; then
        echo "GRACE"; # Just past target = grace period
    else
        echo "COOL";  # Way past target = cooling down
    fi;
}

################################################################################
# _get_activity_code - Determine what the poller is doing
################################################################################
_get_activity_code() {
    local whois_output="$1";
    local expect_pattern="${2:-}";
    
    # Custom pattern specified
    if [[ -n "$expect_pattern" ]]; then
        echo "PTRN";
        return 0;
    fi;
    
    # Analyze WHOIS output to determine activity
    if echo "$whois_output" | grep -qi "pending.*delete\|pendingdelete"; then
        echo "DROP";   # Waiting for domain drop
    elif echo "$whois_output" | grep -qi "no match\|not found\|available"; then
        echo "AVAL";   # Checking availability
    elif echo "$whois_output" | grep -qi "expir\|expires"; then
        echo "EXPR";   # Tracking expiration
    elif echo "$whois_output" | grep -qi "hold\|lock\|suspend"; then
        echo "STAT";   # Monitoring status changes
    else
        echo "POLL";   # General polling
    fi;
}

################################################################################
# _format_status_line - Create live polling status line
################################################################################
_format_status_line() {
    local domain="$1";
    local next_poll_seconds="$2";
    local target_epoch="$3";
    local current_epoch="$4";
    local whois_output="$5";
    local expect_pattern="${6:-}";
    local use_utc="${7:-0}";
    
    local phase glyph color activity timer target_time time_mode;
    
    # Determine phase and get visual elements
    phase=$(_determine_phase "$target_epoch" "$current_epoch");
    glyph=$(_get_phase_glyph "$phase");
    color=$(_get_phase_color "$phase");
    
    # Determine activity
    activity=$(_get_activity_code "$whois_output" "$expect_pattern");
    
    # Format timer (next poll countdown)
    timer=$(_format_timer "$next_poll_seconds");
    
    # Format target time distance
    if [[ "$target_epoch" -gt 0 ]]; then
        local time_to_target=$((target_epoch - current_epoch));
        target_time=$(_format_target_time "$time_to_target");
    else
        target_time="none";
    fi;
    
    # Time mode indicator
    time_mode=$([ "$use_utc" -eq 1 ] && echo "UTC" || echo "LOCAL");
    
    # Build status line
    printf "%s%s %s%s | %s | %s | %s | %s | %s" \
        "$color" "$glyph" "$phase" "$x" \
        "$activity" \
        "$timer" \
        "$target_time" \
        "$domain" \
        "$time_mode";
}

################################################################################
# _print_live_line - Print status line with cursor control
################################################################################
_print_live_line() {
    local status_line="$1";
    
    # Clear current line and print status
    printf "\r\033[K%s" "$status_line";
}

################################################################################
# _format_completion_message - Format final completion message  
################################################################################
_format_completion_message() {
    local success="$1";          # 0=success, 1=failure/timeout
    local domain="$2";
    local domain_status="$3";    # AVAILABLE, REGISTERED, etc.
    local registrar="$4";        # VERISIGN, GODADDY, etc.
    local total_time="$5";       # Total monitoring time
    local activity="$6";         # What we were doing
    local completion_epoch="$7";
    
    local symbol color completion_time result_text;
    
    # Format completion time (12h with am/pm)
    completion_time=$(_format_completion_time "$completion_epoch");
    
    # Determine success/failure styling and text
    if [[ "$success" -eq 0 ]]; then
        symbol="$pass";
        color="$green";
        case "$activity" in
            (DROP)  result_text="DROP success" ;;
            (AVAL)  result_text="AVAL success" ;;
            (PTRN)  result_text="PTRN matched" ;;
            (EXPR)  result_text="EXPR detected" ;;
            (*)     result_text="POLL success" ;;
        esac;
    else
        symbol="$fail";
        color="$red";
        case "$activity" in
            (DROP)  result_text="DROP timeout" ;;
            (AVAL)  result_text="AVAL timeout" ;;
            (PTRN)  result_text="PTRN timeout" ;;
            (EXPR)  result_text="EXPR timeout" ;;
            (*)     result_text="POLL timeout" ;;
        esac;
    fi;
    
    # Print completion message
    printf "\n%s%s %s at %s | %s %s | %s | %s%s\n" \
        "$color" "$symbol" "$result_text" "$completion_time" \
        "$domain" "$domain_status" "$registrar" "$total_time" "$x";
}

################################################################################
# _format_countdown - Format countdown display (FIX: was returning empty)
################################################################################
_format_countdown() {
    local target_epoch="$1";
    local current_epoch="${2:-$(__get_current_epoch)}";
    local use_utc="${3:-0}";
    
    local time_diff target_display current_display remaining_display;
    
    # Calculate time difference
    time_diff=$((target_epoch - current_epoch));
    
    # Format target time
    target_display=$(__format_time_display "$target_epoch" "$use_utc");
    
    # Format current time  
    current_display=$(__format_time_display "$current_epoch" "$use_utc");
    
    # Format remaining time
    if [[ $time_diff -gt 0 ]]; then
        remaining_display="$(_human_time "$time_diff") remaining";
    elif [[ $time_diff -eq 0 ]]; then
        remaining_display="TARGET REACHED";
    else
        remaining_display="$(_human_time $((time_diff * -1))) past target";
    fi;
    
    # Print formatted countdown
    printf "%s\n" "$remaining_display";
    printf "Target: %s\n" "$target_display";
    printf "Current: %s\n" "$current_display";
}

################################################################################
# _calculate_interval - Calculate polling interval based on phase
################################################################################
_calculate_interval() {
    local base_interval="$1";
    local phase="$2";
    local time_to_target="$3";
    
    local interval="$base_interval";
    
    case "$phase" in
        (POLL)
            # Normal polling - use base interval
            interval="$base_interval";
            ;;
        (HEAT)
            # Aggressive polling as target approaches
            if [[ $time_to_target -le 300 ]]; then      # <= 5 minutes
                interval=10;
            elif [[ $time_to_target -le 1800 ]]; then   # <= 30 minutes
                interval=30;
            else
                interval="$base_interval";
            fi;
            ;;
        (GRACE)
            # Continue aggressive polling just past target
            interval=10;
            ;;
        (COOL)
            # Back off with longer intervals
            interval=$((base_interval * 2));
            [[ $interval -gt 3600 ]] && interval=3600;  # Max 1 hour
            ;;
        (*)
            interval="$base_interval";
            ;;
    esac;
    
    echo "$interval";
}

# === 07_commands.sh ===
################################################################################
# commands (do_*) - business logic with enhanced UX (Phase 2)
################################################################################

################################################################################
# do_query - Single WHOIS query command with enhanced output
################################################################################
do_query() {
    local domain="$1";
    local ret=1;
    
    # Validate input
    if ! _validate_domain "$domain"; then
        return 2;
    fi;
    
    # Load TLD configuration
    _load_tld_config;
    
    info "Performing single WHOIS query for %s" "$domain";
    
    # Execute WHOIS query
    local whois_output;
    if whois_output=$(__whois_query "$domain"); then
        # Extract domain status and registrar
        local domain_status registrar;
        domain_status=$(__extract_domain_status "$whois_output");
        registrar=$(__extract_registrar "$whois_output");
        
        # Enhanced results display with colors and glyphs
        printf "\n%s%s Domain Query Results %s%s\n" "$blue" "$lambda" "$lambda" "$x";
        printf "%sDomain:%s %s\n" "$white" "$x" "$domain";
        
        # Status with appropriate color
        case "$domain_status" in
            (AVAILABLE)
                printf "%sStatus:%s %s%s %s%s\n" "$white" "$x" "$green" "$pass" "$domain_status" "$x";
                ret=0;  # Success - domain is available
                ;;
            (PENDING-DELETE)
                printf "%sStatus:%s %s%s %s%s\n" "$white" "$x" "$yellow" "$delta" "$domain_status" "$x";
                ret=1;  # Pending status
                ;;
            (*)
                printf "%sStatus:%s %s%s %s%s\n" "$white" "$x" "$red" "$fail" "$domain_status" "$x";
                ret=1;  # Not available
                ;;
        esac;
        
        printf "%sRegistrar:%s %s\n" "$white" "$x" "$registrar";
        
        # Show query timestamp
        printf "%sQueried:%s %s\n" "$white" "$x" "$(date '+%Y-%m-%d %H:%M:%S %Z')";
        
        # Raw WHOIS output in collapsed format
        printf "\n%s%s Raw WHOIS Output:%s\n" "$grey" "$delta" "$x";
        echo "$whois_output" | head -20;
        local total_lines;
        total_lines=$(echo "$whois_output" | wc -l);
        if [[ $total_lines -gt 20 ]]; then
            printf "%s... (%d more lines, use -t for full output)%s\n" "$grey" $((total_lines - 20)) "$x";
        fi;
        
    else
        error "WHOIS query failed for %s" "$domain";
        ret=3;
    fi;
    
    return $ret;
}

################################################################################
# do_watch - Domain monitoring with enhanced live UX
################################################################################
do_watch() {
    local domain="$1";
    local interval="${opt_interval:-$DEFAULT_INTERVAL}";
    local max_checks="${opt_max_checks:-$DEFAULT_MAX_CHECKS}";
    local target_epoch=0;
    local expect_pattern="${opt_expect:-}";
    local use_utc="${opt_time_utc:-0}";
    local ret=1;
    
    # Validate inputs
    if ! _validate_domain "$domain"; then
        return 2;
    fi;
    
    if ! _validate_interval "$interval"; then
        return 2;
    fi;
    
    # Parse target time if provided
    if [[ -n "${opt_until:-}" ]]; then
        if ! target_epoch=$(__parse_epoch "${opt_until}"); then
            error "Invalid target time: %s" "${opt_until}";
            return 4;
        fi;
        info "Target time set: %s" "$(__format_time_display "$target_epoch" "$use_utc")";
    fi;
    
    # Check dependencies
    if ! _check_dependencies; then
        return 3;
    fi;
    
    # Load TLD configuration
    _load_tld_config;
    
    # Enhanced startup display
    printf "\n%s%s Watchdom Monitor Starting %s%s\n" "$blue" "$lambda" "$lambda" "$x";
    printf "%sDomain:%s %s\n" "$white" "$x" "$domain";
    printf "%sInterval:%s %ss base, phase-aware scaling\n" "$white" "$x" "$interval";
    if [[ "$target_epoch" -gt 0 ]]; then
        printf "%sTarget:%s %s\n" "$white" "$x" "$(__format_time_display "$target_epoch" "$use_utc")";
    fi;
    printf "%sPhases:%s %s%sPOLL %s%sHEAT %s%sGRACE %s%sCOOL%s\n" "$white" "$x" "$blue" "$lambda" "$red" "$triangle" "$purple" "$triangle_up" "$cyan" "$snowflake" "$x";
    printf "\n";
    
    # Start monitoring
    _start_polling "$domain" "$interval" "$max_checks" "$target_epoch" "$expect_pattern" "$use_utc";
    ret=$?;
    
    return $ret;
}

################################################################################
# _start_polling - Enhanced polling loop with superior UX
################################################################################
_start_polling() {
    local domain="$1";
    local base_interval="$2";
    local max_checks="$3";
    local target_epoch="$4";
    local expect_pattern="$5";
    local use_utc="$6";
    
    local check_count=0;
    local start_epoch=$(__get_current_epoch);
    local whois_output="" domain_status="" registrar="";
    local matched=0;
    local previous_phase="";
    
    info "Starting enhanced monitoring for %s with base interval=%ss" "$domain" "$base_interval";
    [[ "$target_epoch" -gt 0 ]] && info "Target UTC: %s" "$(__format_time_display "$target_epoch" 1)";
    
    while true; do
        ((check_count++));
        local current_epoch=$(__get_current_epoch);
        
        # Execute WHOIS query
        if ! whois_output=$(__whois_query "$domain"); then
            error "WHOIS query failed, stopping monitoring";
            return 3;
        fi;
        
        # Extract domain information
        domain_status=$(__extract_domain_status "$whois_output");
        registrar=$(__extract_registrar "$whois_output");
        
        # Check for pattern match
        if _check_pattern_match "$whois_output" "$expect_pattern" "$domain_status"; then
            matched=1;
            break;
        fi;
        
        # Check max checks limit
        if [[ "$max_checks" -gt 0 && "$check_count" -ge "$max_checks" ]]; then
            warn "Maximum checks (%d) reached" "$max_checks";
            break;
        fi;
        
        # Calculate next poll interval based on phase
        local phase=$(_determine_phase "$target_epoch" "$current_epoch");
        local time_to_target=$((target_epoch - current_epoch));
        local next_interval=$(_calculate_interval "$base_interval" "$phase" "$time_to_target");
        
        # Enhanced phase transition detection
        if [[ "$phase" != "$previous_phase" && -n "$previous_phase" ]]; then
            _announce_phase_transition "$previous_phase" "$phase" "$time_to_target";
        fi;
        previous_phase="$phase";
        
        # Display enhanced live status line
        local status_line;
        status_line=$(_format_enhanced_status_line "$domain" "$next_interval" "$target_epoch" "$current_epoch" "$whois_output" "$expect_pattern" "$use_utc" "$check_count");
        _print_live_line "$status_line";
        
        # Check grace period timeout
        if _check_grace_timeout "$target_epoch" "$current_epoch" "$domain"; then
            break;
        fi;
        
        # Sleep until next poll
        trace "Sleeping %ss until next poll (phase: %s)" "$next_interval" "$phase";
        sleep "$next_interval";
    done;
    
    # Calculate total monitoring time
    local end_epoch=$(__get_current_epoch);
    local total_time=$(_human_time $((end_epoch - start_epoch)));
    local activity=$(_get_activity_code "$whois_output" "$expect_pattern");
    
    # Enhanced completion message with celebration
    _format_enhanced_completion_message "$matched" "$domain" "$domain_status" "$registrar" "$total_time" "$activity" "$end_epoch" "$check_count";
    
    return $((1 - matched));  # 0 if matched, 1 if not
}

################################################################################
# _announce_phase_transition - Announce phase changes prominently
################################################################################
_announce_phase_transition() {
    local old_phase="$1";
    local new_phase="$2";
    local time_to_target="$3";
    
    local old_glyph new_glyph old_color new_color;
    old_glyph=$(_get_phase_glyph "$old_phase");
    new_glyph=$(_get_phase_glyph "$new_phase");
    old_color=$(_get_phase_color "$old_phase");
    new_color=$(_get_phase_color "$new_phase");
    
    printf "\n\n%s%s Phase Transition %s%s\n" "$yellow" "$spark" "$spark" "$x";
    printf "%s%s %s%s %sâ†’%s %s%s %s%s\n" "$old_color" "$old_glyph" "$old_phase" "$x" "$yellow" "$x" "$new_color" "$new_glyph" "$new_phase" "$x";
    
    case "$new_phase" in
        (HEAT)
            printf "%sEntering aggressive polling phase - target approaching!%s\n" "$red" "$x";
            ;;
        (GRACE)
            printf "%sTarget time reached - entering grace period monitoring%s\n" "$purple" "$x";
            ;;
        (COOL)
            printf "%sEntering cooldown phase - backing off polling frequency%s\n" "$cyan" "$x";
            ;;
    esac;
    printf "\n";
}

################################################################################
# _format_enhanced_status_line - Enhanced status line with better formatting
################################################################################
_format_enhanced_status_line() {
    local domain="$1";
    local next_poll_seconds="$2";
    local target_epoch="$3";
    local current_epoch="$4";
    local whois_output="$5";
    local expect_pattern="${6:-}";
    local use_utc="${7:-0}";
    local check_count="$8";
    
    local phase glyph color activity timer target_time time_mode check_display;
    
    # Determine phase and get visual elements
    phase=$(_determine_phase "$target_epoch" "$current_epoch");
    glyph=$(_get_phase_glyph "$phase");
    color=$(_get_phase_color "$phase");
    
    # Determine activity
    activity=$(_get_activity_code "$whois_output" "$expect_pattern");
    
    # Format timer (next poll countdown)
    timer=$(_format_timer "$next_poll_seconds");
    
    # Format target time distance
    if [[ "$target_epoch" -gt 0 ]]; then
        local time_to_target=$((target_epoch - current_epoch));
        target_time=$(_format_target_time "$time_to_target");
    else
        target_time="none";
    fi;
    
    # Time mode indicator
    time_mode=$([ "$use_utc" -eq 1 ] && echo "UTC" || echo "LOCAL");
    
    # Check count display
    check_display="[#$check_count]";
    
    # Build enhanced status line with better spacing
    printf "%s%s %s%s â”‚ %s â”‚ %s â”‚ %s â”‚ %s â”‚ %s %s%s" \
        "$color" "$glyph" "$phase" "$x" \
        "$activity" \
        "$timer" \
        "$target_time" \
        "$domain" \
        "$time_mode" \
        "$check_display" \
        "$x";
}

################################################################################
# _format_enhanced_completion_message - Celebration and detailed completion
################################################################################
_format_enhanced_completion_message() {
    local success="$1";
    local domain="$2";
    local domain_status="$3";
    local registrar="$4";
    local total_time="$5";
    local activity="$6";
    local completion_epoch="$7";
    local total_checks="$8";
    
    local symbol color completion_time result_text celebration;
    
    # Format completion time (12h with am/pm)
    completion_time=$(_format_completion_time "$completion_epoch");
    
    # Determine success/failure styling and celebration
    if [[ "$success" -eq 0 ]]; then
        symbol="$pass";
        color="$green";
        celebration="ðŸŽ‰";
        case "$activity" in
            (DROP)  result_text="Domain Drop Detected!" ;;
            (AVAL)  result_text="Domain Available!" ;;
            (PTRN)  result_text="Pattern Matched!" ;;
            (EXPR)  result_text="Expiration Detected!" ;;
            (*)     result_text="Success!" ;;
        esac;
    else
        symbol="$fail";
        color="$red";
        celebration="â°";
        case "$activity" in
            (DROP)  result_text="Drop Monitoring Timeout" ;;
            (AVAL)  result_text="Availability Check Timeout" ;;
            (PTRN)  result_text="Pattern Search Timeout" ;;
            (EXPR)  result_text="Expiration Watch Timeout" ;;
            (*)     result_text="Monitoring Timeout" ;;
        esac;
    fi;
    
    # Enhanced completion display
    printf "\n\n%s%s%s Monitoring Complete %s%s%s\n\n" "$color" "$celebration" "$spark" "$spark" "$celebration" "$x";
    printf "%s%s %s%s at %s\n" "$color" "$symbol" "$result_text" "$x" "$completion_time";
    printf "\n%sResults:%s\n" "$white" "$x";
    printf "  %sDomain:%s     %s\n" "$white" "$x" "$domain";
    printf "  %sStatus:%s     %s\n" "$white" "$x" "$domain_status";
    printf "  %sRegistrar:%s  %s\n" "$white" "$x" "$registrar";
    printf "  %sDuration:%s   %s\n" "$white" "$x" "$total_time";
    printf "  %sChecks:%s     %d queries\n" "$white" "$x" "$total_checks";
    printf "  %sActivity:%s   %s monitoring\n" "$white" "$x" "$activity";
    
    # Add trailing completion record for history
    _add_completion_history "$domain" "$domain_status" "$registrar" "$total_time" "$completion_time" "$success";
}

################################################################################
# _add_completion_history - Add completed poll to trailing history
################################################################################
_add_completion_history() {
    local domain="$1";
    local status="$2";
    local registrar="$3";
    local duration="$4";
    local time_done="$5";
    local success="$6";
    
    local result_icon;
    result_icon=$([ "$success" -eq 0 ] && echo "$pass" || echo "$fail");
    
    # Format as trailing grey history entry
    printf "\n%sDone%s %s %s at %s â”‚ %s %s â”‚ %s â”‚ %s â”‚ %s\n" \
        "$grey" "$x" "$result_icon" "$time_done" \
        "$domain" "$status" "$registrar" "$duration" \
        $([ "$success" -eq 0 ] && echo "SUCCESS" || echo "TIMEOUT");
}

################################################################################
# Remaining do_* functions with standard formatting
################################################################################

################################################################################
# do_time - Standalone time countdown mode with enhanced display
################################################################################
do_time() {
    local target_time="$1";
    local use_utc="${opt_time_utc:-0}";
    local target_epoch;
    
    # Validate and parse target time
    if ! target_epoch=$(__parse_epoch "$target_time"); then
        error "Invalid target time: %s" "$target_time";
        return 4;
    fi;
    
    printf "\n%s%s Time Countdown Mode %s%s\n" "$blue" "$lambda" "$lambda" "$x";
    info "Target: %s" "$(__format_time_display "$target_epoch" "$use_utc")";
    
    # Enhanced countdown display
    _format_countdown "$target_epoch" "$(__get_current_epoch)" "$use_utc";
    
    return 0;
}

################################################################################
# Standard do_* functions (unchanged)
################################################################################
do_list_tlds() {
    printf "\n%s%s Supported TLD Configurations %s%s\n\n" "$blue" "$lambda" "$lambda" "$x";
    
    # Load user config
    _load_tld_config;
    
    printf "%-8s %-25s %s\n" "TLD" "WHOIS Server" "Available Pattern";
    printf "%-8s %-25s %s\n" "---" "------------" "-----------------";
    
    # Show built-in and user-configured TLDs
    local tld server pattern;
    for tld in "${!TLD_REGISTRY[@]}"; do
        IFS='|' read -r server pattern <<< "${TLD_REGISTRY[$tld]}";
        printf "%-8s %-25s %s\n" "$tld" "$server" "$pattern";
    done;
    
    printf "\nUser configuration file: %s\n" "$WATCHDOM_RC";
    
    return 0;
}

do_add_tld() {
    local tld="$1";
    local server="$2";
    local pattern="$3";
    
    # Validate inputs
    if [[ -z "$tld" || -z "$server" || -z "$pattern" ]]; then
        error "Usage: add_tld TLD WHOIS_SERVER AVAILABLE_PATTERN";
        return 2;
    fi;
    
    # Ensure TLD starts with dot
    [[ "$tld" != .* ]] && tld=".$tld";
    
    # Add to user configuration
    echo "$tld|$server|$pattern" >> "$WATCHDOM_RC";
    
    okay "Added TLD configuration: %s -> %s | %s" "$tld" "$server" "$pattern";
    return 0;
}

do_test_tld() {
    local tld="$1";
    local test_domain="$2";
    
    if [[ -z "$tld" || -z "$test_domain" ]]; then
        error "Usage: test_tld TLD TEST_DOMAIN";
        return 2;
    fi;
    
    # Load configuration
    _load_tld_config;
    
    # Get TLD configuration
    local config server pattern;
    config=$(_get_tld_config "$test_domain");
    IFS='|' read -r server pattern <<< "$config";
    
    printf "\n%s%s TLD Test Results %s%s\n" "$blue" "$lambda" "$lambda" "$x";
    printf "TLD: %s\n" "$tld";
    printf "Test domain: %s\n" "$test_domain";
    printf "WHOIS server: %s\n" "${server:-default}";
    printf "Expected pattern: %s\n" "${pattern:-available}";
    
    # Execute test query
    local whois_output;
    if whois_output=$(__whois_query "$test_domain"); then
        printf "\n%sPattern Match Test:%s\n" "$yellow" "$x";
        if echo "$whois_output" | grep -qi "${pattern:-available}"; then
            printf "%s%s Pattern MATCHED%s\n" "$green" "$pass" "$x";
            return 0;
        else
            printf "%s%s Pattern NOT matched%s\n" "$red" "$fail" "$x";
            return 1;
        fi;
    else
        error "WHOIS query failed for test domain";
        return 3;
    fi;
}

# === 08_interface.sh ===
################################################################################
# interface - user interface with proper BashFX separation
################################################################################

################################################################################
# usage - Help documentation
################################################################################
usage() {
    cat <<'EOF'
watchdom - registry WHOIS watcher with phase-aware polling

USAGE:
  watchdom COMMAND [OPTIONS]

COMMANDS:
  query DOMAIN                     Single WHOIS lookup
  watch DOMAIN [OPTIONS]           Monitor domain with polling  
  time "DATETIME" [OPTIONS]        Countdown to target time
  list_tlds                        Show supported TLD configurations
  add_tld TLD SERVER PATTERN       Add custom TLD configuration
  test_tld TLD DOMAIN              Test TLD pattern matching
  install                          Install to system paths
  uninstall                        Remove from system paths
  status                           Show installation status

WATCH OPTIONS:
  -i SECONDS      Base polling interval (default: 60)
  -e PATTERN      Expected availability pattern (custom regex)
  -n MAX_CHECKS   Stop after N checks (default: unlimited)
  --until WHEN    Target datetime ("YYYY-MM-DD HH:MM:SS UTC" or epoch)
  --time-utc      Display times in UTC instead of local

GLOBAL OPTIONS:
  -d, --debug     Enable debug messages (default: ON)
  -t, --trace     Enable trace messages (verbose polling)
  -q, --quiet     Force quiet mode (errors only)
  -y, --yes       Auto-confirm prompts
  -h, --help      Show this help

EXAMPLES:
  watchdom query example.com
  watchdom watch example.com -i 30
  watchdom watch premium.com --until "2025-12-25 18:00:00 UTC" -i 10
  watchdom time "2025-12-25 18:00:00 UTC"
  watchdom add_tld .uk whois.nominet.uk "No such domain"

PHASE SYSTEM:
  Î» POLL  - Normal polling intervals
  â–² HEAT  - Aggressive polling as target approaches  
  â–µ GRACE - Post-target monitoring window
  â… COOL  - Backing off with longer intervals

EXIT CODES:
  0: Success (pattern matched/available)
  1: Not found (timeout/unavailable)
  2: Bad arguments
  3: Missing dependencies
  4: Date parse error
EOF
}

################################################################################
# options - Argument parsing (extracted from main for BashFX compliance)
################################################################################
options() {
    # Initialize option variables with defaults
    opt_debug=${DEFAULT_DEBUG};  # Debug ON by default now
    opt_trace=0;
    opt_quiet=0;
    opt_yes=0;
    opt_interval="";
    opt_expect="";
    opt_max_checks="";
    opt_until="";
    opt_time_utc=0;
    
    # Parse all options, separating them from positional arguments
    local args=();
    while [[ $# -gt 0 ]]; do
        case "$1" in
            (-d|--debug) opt_debug=1; shift ;;
            (-t|--trace) opt_trace=1; opt_debug=1; shift ;;
            (-q|--quiet) opt_quiet=1; opt_debug=0; opt_trace=0; shift ;;
            (-y|--yes) opt_yes=1; shift ;;
            (-i)
                [[ $# -ge 2 ]] || { error "Option -i requires an argument"; return 2; };
                opt_interval="$2"; shift 2 ;;
            (-e)
                [[ $# -ge 2 ]] || { error "Option -e requires an argument"; return 2; };
                opt_expect="$2"; shift 2 ;;
            (-n)
                [[ $# -ge 2 ]] || { error "Option -n requires an argument"; return 2; };
                opt_max_checks="$2"; shift 2 ;;
            (--until)
                [[ $# -ge 2 ]] || { error "Option --until requires an argument"; return 2; };
                opt_until="$2"; shift 2 ;;
            (--time-utc|--utc) opt_time_utc=1; shift ;;
            (--time-local) opt_time_utc=0; shift ;;
            (-h|--help) usage; exit 0 ;;
            (--) shift; args+=("$@"); break ;;
            (-*) error "Unknown option: %s" "$1"; usage; return 2 ;;
            (*) args+=("$1"); shift ;;
        esac;
    done;
    
    # Restore positional arguments
    [[ ${#args[@]} -gt 0 ]] && set -- "${args[@]}";
    
    # Apply quiet mode override
    if [[ "$opt_quiet" -eq 1 ]]; then
        opt_debug=0;
        opt_trace=0;
    fi;
    
    # Export parsed arguments
    export opt_debug opt_trace opt_quiet opt_yes opt_interval opt_expect opt_max_checks opt_until opt_time_utc;
    
    # Return remaining arguments via global array
    remaining_args=("$@");
    return 0;
}

################################################################################
# dispatch - Command routing (extracted from main for BashFX compliance)
################################################################################
dispatch() {
    local cmd="${1:-}";
    local ret=1;
    
    # Validate command
    if [[ -z "$cmd" ]]; then
        error "No command specified";
        usage;
        return 2;
    fi;
    
    # Route to command functions
    case "$cmd" in
        (query)
            [[ $# -ge 2 ]] || { error "Command 'query' requires a domain"; return 2; };
            shift;
            do_query "$@";
            ret=$?;
            ;;
        (watch)
            [[ $# -ge 2 ]] || { error "Command 'watch' requires a domain"; return 2; };
            shift;
            do_watch "$@";
            ret=$?;
            ;;
        (time)
            [[ $# -ge 2 ]] || { error "Command 'time' requires a datetime"; return 2; };
            shift;
            do_time "$@";
            ret=$?;
            ;;
        (list_tlds)
            do_list_tlds;
            ret=$?;
            ;;
        (add_tld)
            [[ $# -ge 4 ]] || { error "Command 'add_tld' requires TLD, server, and pattern"; return 2; };
            shift;
            do_add_tld "$@";
            ret=$?;
            ;;
        (test_tld)
            [[ $# -ge 3 ]] || { error "Command 'test_tld' requires TLD and test domain"; return 2; };
            shift;
            do_test_tld "$@";
            ret=$?;
            ;;
        (install)
            do_install;
            ret=$?;
            ;;
        (uninstall)
            do_uninstall;
            ret=$?;
            ;;
        (status)
            do_status;
            ret=$?;
            ;;
        (*)
            error "Unknown command: %s" "$cmd";
            usage;
            ret=2;
            ;;
    esac;
    
    return $ret;
}

################################################################################
# main - Entry point (BashFX compliant: parse and dispatch only)
################################################################################
main() {
    local ret=1;
    
    # Set up signal handling
    trap '_cleanup' INT TERM;
    
    # Parse arguments
    local remaining_args=();
    if ! options "$@"; then
        return 2;
    fi;
    
    # Dispatch to command
    if [[ ${#remaining_args[@]} -gt 0 ]]; then
        dispatch "${remaining_args[@]}";
        ret=$?;
    else
        error "No command specified";
        usage;
        ret=2;
    fi;
    
    return $ret;
}

# === 09_footer.sh ===
################################################################################
# installation commands (do_install, do_uninstall, do_status)
################################################################################

################################################################################
# do_install - Install to XDG+ compliant paths
################################################################################
do_install() {
    local ret=0
    
    # Create directories
    if ! mkdir -p "$FX_LIB_DIR" "$FX_BIN_DIR"; then
        error "Failed to create installation directories"
        return 1
    fi
    
    # Copy script to lib location
    if ! cp "$SELF_PATH" "$FX_INSTALL_PATH"; then
        error "Failed to copy script to %s" "$FX_INSTALL_PATH"
        return 1
    fi
    
    # Create symlink in bin
    if ! ln -sf "$FX_INSTALL_PATH" "$FX_BIN_LINK"; then
        error "Failed to create symlink at %s" "$FX_BIN_LINK"
        return 1
    fi
    
    okay "Installed %s to %s" "$SELF_NAME" "$FX_INSTALL_PATH"
    okay "Created symlink at %s" "$FX_BIN_LINK"
    
    # Check if bin directory is in PATH
    if [[ ":$PATH:" != *":$FX_BIN_DIR:"* ]]; then
        printf "\n%sIMPORTANT:%s Add to your shell profile:\n" "$yellow" "$x"
        printf "export PATH=\"%s:\$PATH\"\n\n" "$FX_BIN_DIR"
    fi
    
    return $ret
}

################################################################################
# do_uninstall - Remove installation
################################################################################
do_uninstall() {
    local ret=0
    local removed_items=0
    
    # Remove symlink
    if [[ -L "$FX_BIN_LINK" ]]; then
        if rm -f "$FX_BIN_LINK"; then
            okay "Removed symlink: %s" "$FX_BIN_LINK"
            removed_items=$((removed_items + 1))
        else
            error "Failed to remove symlink: %s" "$FX_BIN_LINK"
            ret=1
        fi
    fi
    
    # Remove script
    if [[ -f "$FX_INSTALL_PATH" ]]; then
        if rm -f "$FX_INSTALL_PATH"; then
            okay "Removed script: %s" "$FX_INSTALL_PATH"
            removed_items=$((removed_items + 1))
        else
            error "Failed to remove script: %s" "$FX_INSTALL_PATH"
            ret=1
        fi
    fi
    
    # Remove empty directories
    if [[ -d "$FX_LIB_DIR" ]] && [[ -z "$(ls -A "$FX_LIB_DIR" 2>/dev/null)" ]]; then
        if rmdir "$FX_LIB_DIR"; then
            trace "Removed empty directory: %s" "$FX_LIB_DIR"
        fi
    fi
    
    if [[ "$removed_items" -eq 0 ]]; then
        warn "%s was not installed or already removed" "$SELF_NAME"
        ret=1
    else
        okay "Successfully uninstalled %s (%d items removed)" "$SELF_NAME" "$removed_items"
        info "User configuration preserved at %s" "$WATCHDOM_RC"
    fi
    
    return $ret
}

################################################################################
# do_status - Show installation status
################################################################################
do_status() {
    local ret=0
    
    printf "%swatchdom v%s - Installation Status%s\n\n" "$blue" "$SELF_VERSION" "$x"
    
    printf "Current script: %s\n" "$SELF_PATH"
    
    if [[ -f "$FX_INSTALL_PATH" ]]; then
        printf "Installed at  : %s %sâœ“%s\n" "$FX_INSTALL_PATH" "$green" "$x"
    else
        printf "Installed at  : %s %sâœ—%s\n" "$FX_INSTALL_PATH" "$red" "$x"
        ret=1
    fi
    
    if [[ -L "$FX_BIN_LINK" ]]; then
        local link_target
        link_target="$(readlink "$FX_BIN_LINK")"
        printf "Symlink       : %s -> %s %sâœ“%s\n" "$FX_BIN_LINK" "$link_target" "$green" "$x"
    else
        printf "Symlink       : %s %sâœ—%s\n" "$FX_BIN_LINK" "$red" "$x"
        ret=1
    fi
    
    if [[ ":$PATH:" == *":$FX_BIN_DIR:"* ]]; then
        printf "PATH includes : %s %sâœ“%s\n" "$FX_BIN_DIR" "$green" "$x"
    else
        printf "PATH includes : %s %sâœ—%s\n" "$FX_BIN_DIR" "$red" "$x"
    fi
    
    if [[ -f "$WATCHDOM_RC" ]]; then
        local tld_count
        tld_count="$(grep -c '^[^#]' "$WATCHDOM_RC" 2>/dev/null || echo 0)"
        printf "User config   : %s (%s custom TLDs) %sâœ“%s\n" "$WATCHDOM_RC" "$tld_count" "$green" "$x"
    else
        printf "User config   : %s %sâœ—%s\n" "$WATCHDOM_RC" "$yellow" "$x"
    fi
    
    printf "\n"
    
    if [[ "$ret" -eq 0 ]]; then
        okay "watchdom is properly installed and ready to use"
    else
        warn "watchdom installation is incomplete - run 'watchdom install'"
    fi
    
    return $ret
}

################################################################################
# invocation and cleanup
################################################################################

# Signal handlers and cleanup
set -euo pipefail

# Global variables for cleanup
declare -a remaining_args=()

# Invoke main function only when executed directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@";
fi;
