#!/usr/bin/env bash
# Generated by build.sh on Sat Aug 16 10:59:55 AM MDT 2025
# Auto-assembled from numbered modules: 01_header.sh 02_colors.sh 03_helpers.sh 04_literals.sh 05_validators.sh 06_formatters.sh 07_commands.sh 08_interface.sh 09_footer.sh
# === 01_header.sh ===
#!/usr/bin/env bash
# watchdom - registry WHOIS watcher with phase-aware polling
# version: 2.1.0-bashfx-fixed
# portable: whois, date, grep, sed
# builtins: printf, read, local, declare, case, if, for, while

################################################################################
# readonly
################################################################################
readonly SELF_NAME="watchdom"
readonly SELF_VERSION="2.1.0-bashfx-fixed"
readonly SELF_PATH="$(realpath "${BASH_SOURCE[0]}")"
readonly SELF_DIR="$(dirname "$SELF_PATH")"
readonly WATCHDOM_RC="$HOME/.watchdomrc"

# XDG+ compliant paths for BashFX framework
readonly XDG_HOME="${HOME}/.local"
readonly XDG_LIB="${XDG_HOME}/lib"
readonly XDG_BIN="${XDG_HOME}/bin"
readonly XDG_ETC="${XDG_HOME}/etc"
readonly XDG_TMP="${HOME}/.cache/tmp"

# BashFX namespace paths (first-party code goes in /fx/)
readonly FX_LIB_DIR="${XDG_LIB}/fx"
readonly FX_BIN_DIR="${XDG_BIN}/fx"
readonly FX_INSTALL_PATH="${FX_LIB_DIR}/${SELF_NAME}"
readonly FX_BIN_LINK="${FX_BIN_DIR}/${SELF_NAME}"

# Rate limiting and error patterns
readonly RATE_LIMIT_PATTERN="rate limit|exceeded|too many|try again|access denied|quota"

################################################################################
# config
################################################################################
# Default settings (overridable by environment)
DEFAULT_INTERVAL="${WATCHDOM_INTERVAL:-60}"
DEFAULT_MAX_CHECKS="${WATCHDOM_MAX_CHECKS:-0}"
DEFAULT_TIME_LOCAL="${WATCHDOM_TIME_LOCAL:-1}"

# Email notification settings (all must be set to enable notifications)
NOTIFY_EMAIL="${NOTIFY_EMAIL:-}"           # Recipient email
NOTIFY_FROM="${NOTIFY_FROM:-}"             # Sender email  
NOTIFY_SMTP_HOST="${NOTIFY_SMTP_HOST:-}"   # SMTP server
NOTIFY_SMTP_PORT="${NOTIFY_SMTP_PORT:-}"   # SMTP port
NOTIFY_SMTP_USER="${NOTIFY_SMTP_USER:-}"   # SMTP username
NOTIFY_SMTP_PASS="${NOTIFY_SMTP_PASS:-}"   # SMTP password

# Phase timing thresholds (in seconds)
readonly HEAT_THRESHOLD=1800    # 30 minutes - switch to HEAT phase
readonly GRACE_THRESHOLD=10800  # 3 hours - switch to COOL phase

# TLD Registry defaults (can be extended via ~/.watchdomrc)
declare -A TLD_REGISTRY=(
    [".com"]="whois.verisign-grs.com|No match for"
    [".net"]="whois.verisign-grs.com|No match for"
    [".org"]="whois.pir.org|NOT FOUND"
    [".info"]="whois.afilias.net|Not found"
    [".biz"]="whois.nic.biz|Not found"
)
# === 02_colors.sh ===
################################################################################
# escape sequences (BashFX standard from esc.sh.*)
################################################################################
readonly red=$'\x1B[31m'
readonly green=$'\x1B[32m'
readonly blue=$'\x1B[34m'
readonly yellow=$'\x1B[33m'
readonly purple=$'\x1B[35m'
readonly cyan=$'\x1B[36m'
readonly grey=$'\x1B[38;5;244m'
readonly red2=$'\x1B[38;5;196m'
readonly x=$'\x1B[38;5;244m'

################################################################################
# glyphs (phase indicators and symbols)
################################################################################
readonly lambda=$'\xCE\xBB'              # λ - POLL phase
readonly triangle=$'\xe2\x96\xb2'        # ▲ - HEAT phase  
readonly triangle_up=$'\xe2\x96\xb5'     # ▵ - GRACE phase
readonly snowflake=$'\xe2\x9d\x85'       # ❅ - COOL phase
readonly pass=$'\xe2\x9c\x93'            # ✓ - success
readonly fail=$'\xe2\x9c\x97'            # ✗ - failure
readonly delta=$'\xe2\x96\xb3'           # △ - warning/change
readonly spark=$'\xe2\x9c\xa8'           # ✨ - completion

################################################################################
# phase color mapping
################################################################################
_get_phase_color() {
    local phase="$1"
    case "$phase" in
        (POLL)  echo "$blue" ;;
        (HEAT)  echo "$red" ;;
        (GRACE) echo "$purple" ;;
        (COOL)  echo "$cyan" ;;
        (*)     echo "$grey" ;;
    esac
}

_get_phase_glyph() {
    local phase="$1"
    case "$phase" in
        (POLL)  echo "$lambda" ;;
        (HEAT)  echo "$triangle" ;;
        (GRACE) echo "$triangle_up" ;;
        (COOL)  echo "$snowflake" ;;
        (*)     echo "?" ;;
    esac
}
# === 03_helpers.sh ===
################################################################################
# simple stderr (BashFX compliant logging)
################################################################################
info()  { [[ ${opt_debug:-0} -eq 1 ]] && printf "%s[%s]%s %s\n" "$blue" "$(date +%H:%M:%S)" "$x" "$*" >&2; }
okay()  { [[ ${opt_debug:-0} -eq 1 ]] && printf "%s%s%s %s\n" "$green" "$pass" "$x" "$*" >&2; }
warn()  { [[ ${opt_debug:-0} -eq 1 ]] && printf "%s%s%s %s\n" "$yellow" "$delta" "$x" "$*" >&2; }
error() { printf "%s%s%s %s\n" "$red" "$fail" "$x" "$*" >&2; }
fatal() { printf "%s%s%s %s\n" "$red2" "$fail" "$x" "$*" >&2; exit 1; }
trace() { [[ ${opt_trace:-0} -eq 1 ]] && printf "%s[%s]%s %s\n" "$grey" "$(date +%H:%M:%S)" "$x" "$*" >&2; }

################################################################################
# utility helpers
################################################################################
_human_time() {
    local s=$1 d h m
    ((d=s/86400, s%=86400, h=s/3600, s%=3600, m=s/60, s%=60))
    local out=""
    [[ $d -gt 0 ]] && out+="${d}d "
    [[ $h -gt 0 ]] && out+="${h}h "
    [[ $m -gt 0 ]] && out+="${m}m "
    out+="${s}s"
    echo "$out"
}

_format_timer() {
    local seconds="$1"
    
    if [[ $seconds -lt 60 ]]; then
        # Use "30s" format for seconds only
        echo "${seconds}s"
    elif [[ $seconds -lt 3600 ]]; then
        # Use "5:30" format for minutes:seconds
        printf "%d:%02d" $((seconds/60)) $((seconds%60))
    elif [[ $seconds -lt 86400 ]]; then
        # Use "1:30:27" format for hours:minutes:seconds
        printf "%d:%02d:%02d" $((seconds/3600)) $(((seconds%3600)/60)) $((seconds%60))
    else
        # Use "2d 1:30:27" format for days + time
        local days=$((seconds/86400))
        local remaining=$((seconds%86400))
        printf "%dd %d:%02d:%02d" $days $((remaining/3600)) $(((remaining%3600)/60)) $((remaining%60))
    fi
}

_format_target_time() {
    local seconds="$1"
    local sign=""
    
    # Handle negative time (past target)
    if [[ $seconds -lt 0 ]]; then
        sign="-"
        seconds=$((seconds * -1))
    fi
    
    # Use same format as timer but with sign
    echo "${sign}$(_format_timer "$seconds")"
}

_format_completion_time() {
    local epoch="$1"
    # 12h format with am/pm lowercase
    date -d "@$epoch" "+%-I:%M:%S %P" 2>/dev/null || date -r "$epoch" "+%-I:%M:%S %P"
}

_cleanup() {
    local grace_files
    grace_files=$(find /tmp -name ".watchdom_grace_*_$$" 2>/dev/null || true)
    if [[ -n "$grace_files" ]]; then
        rm -f $grace_files 2>/dev/null || true
    fi
    printf "\n" >&2
    info "Monitoring stopped"
    exit 130
}
# === 04_literals.sh ===
################################################################################
# literals (__*) - atomic operations (PHASE 1 CRITICAL FIXES)
################################################################################

################################################################################
# __parse_epoch - FIX: Returns empty epochs
################################################################################
__parse_epoch() {
    local when="$1"
    local epoch=""
    
    # If already epoch, return it
    if [[ "$when" =~ ^[0-9]+$ ]]; then
        echo "$when"
        return 0
    fi
    
    # Try GNU date first (most common)
    if epoch=$(date -u -d "$when" +%s 2>/dev/null); then
        echo "$epoch"
        return 0
    fi
    
    # Try BSD date (macOS)
    if epoch=$(date -u -j -f "%Y-%m-%d %H:%M:%S" "$when" +%s 2>/dev/null); then
        echo "$epoch"
        return 0
    fi
    
    # Try gdate (macOS with GNU coreutils)
    if command -v gdate >/dev/null 2>&1; then
        if epoch=$(gdate -u -d "$when" +%s 2>/dev/null); then
            echo "$epoch"
            return 0
        fi
    fi
    
    # Last resort: try common format variations
    local formatted_when
    # Handle common input variations
    formatted_when=$(echo "$when" | sed 's/UTC$//' | sed 's/  */ /g' | sed 's/^ *//' | sed 's/ *$//')
    
    if epoch=$(date -u -d "$formatted_when UTC" +%s 2>/dev/null); then
        echo "$epoch"
        return 0
    fi
    
    error "Cannot parse datetime: %s" "$when"
    return 1
}

################################################################################
# __whois_query - FIX: No domain status extraction
################################################################################
__whois_query() {
    local domain="$1"
    local whois_output=""
    local ret=0
    
    # Check if whois command exists
    if ! command -v whois >/dev/null 2>&1; then
        error "Required command 'whois' not found"
        return 3
    fi
    
    trace "Executing WHOIS query for %s" "$domain"
    
    # Execute whois with timeout and error handling
    if ! whois_output=$(timeout 30 whois "$domain" 2>/dev/null); then
        error "WHOIS query failed for %s (timeout or network error)" "$domain"
        return 1
    fi
    
    # Check for empty output
    if [[ -z "$whois_output" ]]; then
        error "WHOIS query returned empty result for %s" "$domain"
        return 1
    fi
    
    # Check for rate limiting
    if echo "$whois_output" | grep -Eqi "$RATE_LIMIT_PATTERN"; then
        error "Rate limited by WHOIS server for %s" "$domain"
        return 2
    fi
    
    trace "WHOIS query completed successfully for %s" "$domain"
    echo "$whois_output"
    return 0
}

################################################################################
# __extract_domain_status - FIX: Missing lifecycle info
################################################################################
__extract_domain_status() {
    local whois_output="$1"
    local status="UNKNOWN"
    
    # Check for availability patterns (most specific first)
    if echo "$whois_output" | grep -qi "no match for\|not found\|no entries found\|available"; then
        status="AVAILABLE"
    elif echo "$whois_output" | grep -qi "pending.*delete\|pendingdelete"; then
        status="PENDING-DELETE"
    elif echo "$whois_output" | grep -qi "client.*hold\|server.*hold"; then
        status="ON-HOLD"
    elif echo "$whois_output" | grep -qi "redemption.*period\|rgp"; then
        status="REDEMPTION"
    elif echo "$whois_output" | grep -qi "domain.*name.*server\|name.*server"; then
        status="REGISTERED"
    elif echo "$whois_output" | grep -qi "reserved\|premium"; then
        status="RESERVED"
    fi
    
    echo "$status"
}

################################################################################
# __extract_registrar - Extract registrar information
################################################################################
__extract_registrar() {
    local whois_output="$1"
    local registrar="UNKNOWN"
    
    # Try to extract registrar name
    if registrar=$(echo "$whois_output" | grep -i "registrar:" | head -1 | sed 's/.*registrar: *//i' | sed 's/ *$//' | tr -d '\r'); then
        [[ -n "$registrar" ]] && echo "$registrar" && return 0
    fi
    
    # Try alternative patterns
    if registrar=$(echo "$whois_output" | grep -i "sponsoring registrar:" | head -1 | sed 's/.*sponsoring registrar: *//i' | sed 's/ *$//' | tr -d '\r'); then
        [[ -n "$registrar" ]] && echo "$registrar" && return 0
    fi
    
    # Default patterns for major registries
    if echo "$whois_output" | grep -qi "verisign"; then
        echo "VERISIGN"
    elif echo "$whois_output" | grep -qi "godaddy"; then
        echo "GODADDY"
    elif echo "$whois_output" | grep -qi "namecheap"; then
        echo "NAMECHEAP"
    else
        echo "UNKNOWN"
    fi
}

################################################################################
# __get_current_epoch - Current time as epoch
################################################################################
__get_current_epoch() {
    date +%s
}

################################################################################
# __format_time_display - Format time for display
################################################################################
__format_time_display() {
    local epoch="$1"
    local use_utc="${2:-0}"
    
    if [[ "$use_utc" -eq 1 ]]; then
        date -u -d "@$epoch" "+%a %b %d %H:%M:%S UTC %Y" 2>/dev/null || date -u -r "$epoch" "+%a %b %d %H:%M:%S UTC %Y"
    else
        date -d "@$epoch" "+%a %b %d %H:%M:%S %Z %Y" 2>/dev/null || date -r "$epoch" "+%a %b %d %H:%M:%S %Z %Y"
    fi
}
# === 05_validators.sh ===
################################################################################
# validators (_*) - input validation and state checking
################################################################################

################################################################################
# _validate_domain - Domain format validation
################################################################################
_validate_domain() {
    local domain="$1"
    
    # Check basic format
    if [[ ! "$domain" =~ ^[a-zA-Z0-9][a-zA-Z0-9.-]*[a-zA-Z0-9]\.[a-zA-Z]{2,}$ ]]; then
        error "Invalid domain format: %s" "$domain"
        return 1
    fi
    
    # Check length limits
    if [[ ${#domain} -gt 253 ]]; then
        error "Domain name too long: %s" "$domain"
        return 1
    fi
    
    # Check for double dots or invalid characters
    if [[ "$domain" =~ \.\. ]] || [[ "$domain" =~ ^[.-] ]] || [[ "$domain" =~ [.-]$ ]]; then
        error "Invalid domain format: %s" "$domain"
        return 1
    fi
    
    trace "Domain validation passed: %s" "$domain"
    return 0
}

################################################################################
# _validate_datetime - Date string validation
################################################################################
_validate_datetime() {
    local when="$1"
    local epoch=""
    
    # Try to parse - if it works, it's valid
    if epoch=$(__parse_epoch "$when"); then
        trace "Datetime validation passed: %s -> %s" "$when" "$epoch"
        return 0
    else
        error "Invalid datetime format: %s" "$when"
        return 1
    fi
}

################################################################################
# _validate_interval - Polling interval validation
################################################################################
_validate_interval() {
    local interval="$1"
    
    # Check if numeric
    if [[ ! "$interval" =~ ^[0-9]+$ ]]; then
        error "Interval must be numeric: %s" "$interval"
        return 1
    fi
    
    # Check minimum (warn for aggressive polling)
    if [[ "$interval" -lt 10 ]]; then
        warn "Interval %ss may trigger rate limits from WHOIS servers" "$interval"
    fi
    
    # Check maximum (sanity check)
    if [[ "$interval" -gt 86400 ]]; then
        warn "Interval %ss is longer than 24 hours" "$interval"
    fi
    
    trace "Interval validation passed: %ss" "$interval"
    return 0
}

################################################################################
# _check_dependencies - Required command validation
################################################################################
_check_dependencies() {
    local missing=0
    
    # Check for whois
    if ! command -v whois >/dev/null 2>&1; then
        error "Required command 'whois' not found"
        info "Install with: apt-get install whois (Ubuntu/Debian) or brew install whois (macOS)"
        missing=1
    fi
    
    # Check for date command
    if ! command -v date >/dev/null 2>&1; then
        error "Required command 'date' not found"
        missing=1
    fi
    
    # Check for timeout command (optional but recommended)
    if ! command -v timeout >/dev/null 2>&1; then
        warn "Command 'timeout' not found - WHOIS queries may hang"
    fi
    
    if [[ "$missing" -eq 1 ]]; then
        return 1
    fi
    
    trace "All dependencies satisfied"
    return 0
}

################################################################################
# _is_tld_supported - Check if TLD has configuration
################################################################################
_is_tld_supported() {
    local domain="$1"
    local tld=""
    
    # Extract TLD
    tld=$(echo "$domain" | grep -o '\.[^.]*$')
    
    # Check in built-in registry
    if [[ -n "${TLD_REGISTRY[$tld]:-}" ]]; then
        trace "TLD %s supported (built-in)" "$tld"
        return 0
    fi
    
    # Check in user config if it exists
    if [[ -f "$WATCHDOM_RC" ]] && grep -q "^$tld|" "$WATCHDOM_RC" 2>/dev/null; then
        trace "TLD %s supported (user config)" "$tld"
        return 0
    fi
    
    warn "TLD %s not configured - using generic WHOIS" "$tld"
    return 1
}

################################################################################
# _load_tld_config - Load TLD configuration from user file
################################################################################
_load_tld_config() {
    local tld_file="$WATCHDOM_RC"
    local line tld server pattern
    
    [[ ! -f "$tld_file" ]] && return 0
    
    trace "Loading TLD configuration from %s" "$tld_file"
    
    while IFS='|' read -r tld server pattern; do
        # Skip comments and empty lines
        [[ "$tld" =~ ^#.*$ ]] || [[ -z "$tld" ]] && continue
        
        # Validate format
        if [[ -n "$tld" && -n "$server" && -n "$pattern" ]]; then
            TLD_REGISTRY["$tld"]="$server|$pattern"
            trace "Loaded TLD config: %s -> %s | %s" "$tld" "$server" "$pattern"
        fi
    done < "$tld_file"
    
    return 0
}

################################################################################
# _get_tld_config - Get WHOIS server and pattern for TLD
################################################################################
_get_tld_config() {
    local domain="$1"
    local tld server pattern
    
    # Extract TLD
    tld=$(echo "$domain" | grep -o '\.[^.]*$')
    
    # Look up in registry
    local config="${TLD_REGISTRY[$tld]:-}"
    
    if [[ -n "$config" ]]; then
        server=$(echo "$config" | cut -d'|' -f1)
        pattern=$(echo "$config" | cut -d'|' -f2)
        echo "$server|$pattern"
        return 0
    fi
    
    # Fallback to generic
    echo "|available"
    return 1
}
# === 06_formatters.sh ===
################################################################################
# formatters (_*) - visual display and status line formatting
################################################################################

################################################################################
# _determine_phase - Calculate current polling phase
################################################################################
_determine_phase() {
    local target_epoch="$1"
    local current_epoch="$2"
    local time_diff=$((target_epoch - current_epoch))
    
    # No target set = POLL phase
    if [[ "$target_epoch" -eq 0 ]]; then
        echo "POLL"
        return 0
    fi
    
    # Before target
    if [[ $time_diff -gt $HEAT_THRESHOLD ]]; then
        echo "POLL"  # More than 30 minutes = normal polling
    elif [[ $time_diff -gt 0 ]]; then
        echo "HEAT"  # Approaching target = aggressive polling
    elif [[ $((current_epoch - target_epoch)) -lt $GRACE_THRESHOLD ]]; then
        echo "GRACE" # Just past target = grace period
    else
        echo "COOL"  # Way past target = cooling down
    fi
}

################################################################################
# _get_activity_code - Determine what the poller is doing
################################################################################
_get_activity_code() {
    local whois_output="$1"
    local expect_pattern="${2:-}"
    
    # Custom pattern specified
    if [[ -n "$expect_pattern" ]]; then
        echo "PTRN"
        return 0
    fi
    
    # Analyze WHOIS output to determine activity
    if echo "$whois_output" | grep -qi "pending.*delete\|pendingdelete"; then
        echo "DROP"   # Waiting for domain drop
    elif echo "$whois_output" | grep -qi "no match\|not found\|available"; then
        echo "AVAL"   # Checking availability
    elif echo "$whois_output" | grep -qi "expir\|expires"; then
        echo "EXPR"   # Tracking expiration
    elif echo "$whois_output" | grep -qi "hold\|lock\|suspend"; then
        echo "STAT"   # Monitoring status changes
    else
        echo "POLL"   # General polling
    fi
}

################################################################################
# _format_status_line - Create live polling status line
################################################################################
_format_status_line() {
    local domain="$1"
    local next_poll_seconds="$2"
    local target_epoch="$3"
    local current_epoch="$4"
    local whois_output="$5"
    local expect_pattern="${6:-}"
    local use_utc="${7:-0}"
    
    local phase glyph color activity timer target_time time_mode
    
    # Determine phase and get visual elements
    phase=$(_determine_phase "$target_epoch" "$current_epoch")
    glyph=$(_get_phase_glyph "$phase")
    color=$(_get_phase_color "$phase")
    
    # Determine activity
    activity=$(_get_activity_code "$whois_output" "$expect_pattern")
    
    # Format timer (next poll countdown)
    timer=$(_format_timer "$next_poll_seconds")
    
    # Format target time distance
    if [[ "$target_epoch" -gt 0 ]]; then
        local time_to_target=$((target_epoch - current_epoch))
        target_time=$(_format_target_time "$time_to_target")
    else
        target_time="none"
    fi
    
    # Time mode indicator
    time_mode=$([ "$use_utc" -eq 1 ] && echo "UTC" || echo "LOCAL")
    
    # Build status line
    printf "%s%s %s%s | %s | %s | %s | %s | %s" \
        "$color" "$glyph" "$phase" "$x" \
        "$activity" \
        "$timer" \
        "$target_time" \
        "$domain" \
        "$time_mode"
}

################################################################################
# _print_live_line - Print status line with cursor control
################################################################################
_print_live_line() {
    local status_line="$1"
    
    # Clear current line and print status
    printf "\r\033[K%s" "$status_line"
}

################################################################################
# _format_completion_message - Format final completion message  
################################################################################
_format_completion_message() {
    local success="$1"          # 0=success, 1=failure/timeout
    local domain="$2"
    local domain_status="$3"    # AVAILABLE, REGISTERED, etc.
    local registrar="$4"        # VERISIGN, GODADDY, etc.
    local total_time="$5"       # Total monitoring time
    local activity="$6"         # What we were doing
    local completion_epoch="$7"
    
    local symbol color completion_time result_text
    
    # Format completion time (12h with am/pm)
    completion_time=$(_format_completion_time "$completion_epoch")
    
    # Determine success/failure styling and text
    if [[ "$success" -eq 0 ]]; then
        symbol="$pass"
        color="$green"
        case "$activity" in
            (DROP)  result_text="DROP success" ;;
            (AVAL)  result_text="AVAL success" ;;
            (PTRN)  result_text="PTRN matched" ;;
            (EXPR)  result_text="EXPR detected" ;;
            (*)     result_text="POLL success" ;;
        esac
    else
        symbol="$fail"
        color="$red"
        case "$activity" in
            (DROP)  result_text="DROP timeout" ;;
            (AVAL)  result_text="AVAL timeout" ;;
            (PTRN)  result_text="PTRN timeout" ;;
            (EXPR)  result_text="EXPR timeout" ;;
            (*)     result_text="POLL timeout" ;;
        esac
    fi
    
    # Print completion message
    printf "\n%s%s %s at %s | %s %s | %s | %s%s\n" \
        "$color" "$symbol" "$result_text" "$completion_time" \
        "$domain" "$domain_status" "$registrar" "$total_time" "$x"
}

################################################################################
# _format_countdown - Format countdown display (FIX: was returning empty)
################################################################################
_format_countdown() {
    local target_epoch="$1"
    local current_epoch="${2:-$(__get_current_epoch)}"
    local use_utc="${3:-0}"
    
    local time_diff target_display current_display remaining_display
    
    # Calculate time difference
    time_diff=$((target_epoch - current_epoch))
    
    # Format target time
    target_display=$(__format_time_display "$target_epoch" "$use_utc")
    
    # Format current time  
    current_display=$(__format_time_display "$current_epoch" "$use_utc")
    
    # Format remaining time
    if [[ $time_diff -gt 0 ]]; then
        remaining_display="$(_human_time "$time_diff") remaining"
    elif [[ $time_diff -eq 0 ]]; then
        remaining_display="TARGET REACHED"
    else
        remaining_display="$(_human_time $((time_diff * -1))) past target"
    fi
    
    # Print formatted countdown
    printf "%s\n" "$remaining_display"
    printf "Target: %s\n" "$target_display"
    printf "Current: %s\n" "$current_display"
}

################################################################################
# _calculate_interval - Calculate polling interval based on phase
################################################################################
_calculate_interval() {
    local base_interval="$1"
    local phase="$2"
    local time_to_target="$3"
    
    local interval="$base_interval"
    
    case "$phase" in
        (POLL)
            # Normal polling - use base interval
            interval="$base_interval"
            ;;
        (HEAT)
            # Aggressive polling as target approaches
            if [[ $time_to_target -le 300 ]]; then      # <= 5 minutes
                interval=10
            elif [[ $time_to_target -le 1800 ]]; then   # <= 30 minutes
                interval=30
            else
                interval="$base_interval"
            fi
            ;;
        (GRACE)
            # Continue aggressive polling just past target
            interval=10
            ;;
        (COOL)
            # Back off with longer intervals
            interval=$((base_interval * 2))
            [[ $interval -gt 3600 ]] && interval=3600  # Max 1 hour
            ;;
        (*)
            interval="$base_interval"
            ;;
    esac
    
    echo "$interval"
}
# === 07_commands.sh ===
################################################################################
# commands (do_*) - business logic with proper BashFX hierarchy
################################################################################

################################################################################
# do_query - Single WHOIS query command (FIX: was buried in watch logic)
################################################################################
do_query() {
    local domain="$1"
    local ret=1
    
    # Validate input
    if ! _validate_domain "$domain"; then
        return 2
    fi
    
    # Load TLD configuration
    _load_tld_config
    
    info "Performing single WHOIS query for %s" "$domain"
    
    # Execute WHOIS query
    local whois_output
    if whois_output=$(__whois_query "$domain"); then
        # Extract domain status and registrar
        local domain_status registrar
        domain_status=$(__extract_domain_status "$whois_output")
        registrar=$(__extract_registrar "$whois_output")
        
        # Print results
        printf "\n%sDomain Query Results%s\n" "$blue" "$x"
        printf "Domain: %s\n" "$domain"
        printf "Status: %s\n" "$domain_status"
        printf "Registrar: %s\n" "$registrar"
        printf "\n%sRaw WHOIS Output:%s\n" "$grey" "$x"
        echo "$whois_output"
        
        # Set return code based on status
        if [[ "$domain_status" == "AVAILABLE" ]]; then
            ret=0  # Success - domain is available
        else
            ret=1  # Not available
        fi
    else
        error "WHOIS query failed for %s" "$domain"
        ret=3
    fi
    
    return $ret
}

################################################################################
# do_watch - Domain monitoring with phase-aware polling
################################################################################
do_watch() {
    local domain="$1"
    local interval="${opt_interval:-$DEFAULT_INTERVAL}"
    local max_checks="${opt_max_checks:-$DEFAULT_MAX_CHECKS}"
    local target_epoch=0
    local expect_pattern="${opt_expect:-}"
    local use_utc="${opt_time_utc:-0}"
    local ret=1
    
    # Validate inputs
    if ! _validate_domain "$domain"; then
        return 2
    fi
    
    if ! _validate_interval "$interval"; then
        return 2
    fi
    
    # Parse target time if provided
    if [[ -n "${opt_until:-}" ]]; then
        if ! target_epoch=$(__parse_epoch "${opt_until}"); then
            error "Invalid target time: %s" "${opt_until}"
            return 4
        fi
        info "Target time set: %s" "$(__format_time_display "$target_epoch" "$use_utc")"
    fi
    
    # Check dependencies
    if ! _check_dependencies; then
        return 3
    fi
    
    # Load TLD configuration
    _load_tld_config
    
    # Start monitoring
    _start_polling "$domain" "$interval" "$max_checks" "$target_epoch" "$expect_pattern" "$use_utc"
    ret=$?
    
    return $ret
}

################################################################################
# _start_polling - Polling loop coordination (mid-level helper)
################################################################################
_start_polling() {
    local domain="$1"
    local base_interval="$2"
    local max_checks="$3"
    local target_epoch="$4"
    local expect_pattern="$5"
    local use_utc="$6"
    
    local check_count=0
    local start_epoch=$(__get_current_epoch)
    local whois_output="" domain_status="" registrar=""
    local matched=0
    
    info "Starting monitoring for %s with base interval=%ss" "$domain" "$base_interval"
    [[ "$target_epoch" -gt 0 ]] && info "Target UTC: %s" "$(__format_time_display "$target_epoch" 1)"
    
    while true; do
        ((check_count++))
        local current_epoch=$(__get_current_epoch)
        
        # Execute WHOIS query
        if ! whois_output=$(__whois_query "$domain"); then
            error "WHOIS query failed, stopping monitoring"
            return 3
        fi
        
        # Extract domain information
        domain_status=$(__extract_domain_status "$whois_output")
        registrar=$(__extract_registrar "$whois_output")
        
        # Check for pattern match
        if _check_pattern_match "$whois_output" "$expect_pattern" "$domain_status"; then
            matched=1
            break
        fi
        
        # Check max checks limit
        if [[ "$max_checks" -gt 0 && "$check_count" -ge "$max_checks" ]]; then
            warn "Maximum checks (%d) reached" "$max_checks"
            break
        fi
        
        # Calculate next poll interval based on phase
        local phase=$(_determine_phase "$target_epoch" "$current_epoch")
        local time_to_target=$((target_epoch - current_epoch))
        local next_interval=$(_calculate_interval "$base_interval" "$phase" "$time_to_target")
        
        # Display live status line
        local status_line
        status_line=$(_format_status_line "$domain" "$next_interval" "$target_epoch" "$current_epoch" "$whois_output" "$expect_pattern" "$use_utc")
        _print_live_line "$status_line"
        
        # Check grace period timeout
        if _check_grace_timeout "$target_epoch" "$current_epoch" "$domain"; then
            break
        fi
        
        # Sleep until next poll
        trace "Sleeping %ss until next poll (phase: %s)" "$next_interval" "$phase"
        sleep "$next_interval"
    done
    
    # Calculate total monitoring time
    local end_epoch=$(__get_current_epoch)
    local total_time=$(_human_time $((end_epoch - start_epoch)))
    local activity=$(_get_activity_code "$whois_output" "$expect_pattern")
    
    # Print completion message
    _format_completion_message "$matched" "$domain" "$domain_status" "$registrar" "$total_time" "$activity" "$end_epoch"
    
    return $((1 - matched))  # 0 if matched, 1 if not
}

################################################################################
# _check_pattern_match - Check if domain matches expected pattern
################################################################################
_check_pattern_match() {
    local whois_output="$1"
    local expect_pattern="$2"
    local domain_status="$3"
    
    # Custom pattern specified
    if [[ -n "$expect_pattern" ]]; then
        if echo "$whois_output" | grep -qi "$expect_pattern"; then
            trace "Custom pattern matched: %s" "$expect_pattern"
            return 0
        fi
        return 1
    fi
    
    # Default pattern: look for availability
    if [[ "$domain_status" == "AVAILABLE" ]]; then
        trace "Domain became available"
        return 0
    fi
    
    return 1
}

################################################################################
# _check_grace_timeout - Check if grace period exceeded
################################################################################
_check_grace_timeout() {
    local target_epoch="$1"
    local current_epoch="$2" 
    local domain="$3"
    
    # No target set, no grace period
    [[ "$target_epoch" -eq 0 ]] && return 1
    
    # Before target, no grace period yet
    [[ "$current_epoch" -lt "$target_epoch" ]] && return 1
    
    local time_past_target=$((current_epoch - target_epoch))
    
    # Within grace period
    [[ "$time_past_target" -lt "$GRACE_THRESHOLD" ]] && return 1
    
    # Grace period exceeded - prompt user
    printf "\n\n%sGrace period exceeded%s\n" "$yellow" "$x"
    printf "Target time was %s ago. Continue monitoring %s?\n" "$(_human_time "$time_past_target")" "$domain"
    printf "[y] Yes, keep monitoring  [n] No, exit  [c] Custom interval: "
    
    local response
    if [[ "${opt_yes:-0}" -eq 1 ]]; then
        response="y"
        printf "y (auto-confirmed)\n"
    else
        read -r response
    fi
    
    case "$response" in
        (y|Y|yes|YES)
            info "Continuing monitoring with extended intervals"
            return 1  # Continue monitoring
            ;;
        (n|N|no|NO|"")
            info "User chose to exit monitoring"
            return 0  # Stop monitoring
            ;;
        (c|C|custom|CUSTOM)
            printf "Enter new interval in seconds: "
            local new_interval
            read -r new_interval
            if _validate_interval "$new_interval"; then
                opt_interval="$new_interval"
                info "Interval updated to %ss" "$new_interval"
                return 1  # Continue with new interval
            else
                warn "Invalid interval, continuing with current settings"
                return 1
            fi
            ;;
        (*)
            warn "Invalid response, continuing monitoring"
            return 1
            ;;
    esac
}

################################################################################
# do_time - Standalone time countdown mode
################################################################################
do_time() {
    local target_time="$1"
    local use_utc="${opt_time_utc:-0}"
    local target_epoch
    
    # Validate and parse target time
    if ! target_epoch=$(__parse_epoch "$target_time"); then
        error "Invalid target time: %s" "$target_time"
        return 4
    fi
    
    info "Time countdown mode - target: %s" "$(__format_time_display "$target_epoch" "$use_utc")"
    
    # Simple countdown display
    _format_countdown "$target_epoch" "$(__get_current_epoch)" "$use_utc"
    
    return 0
}

################################################################################
# do_list_tlds - Show supported TLD configurations
################################################################################
do_list_tlds() {
    printf "\n%sSupported TLD Configurations%s\n\n" "$blue" "$x"
    
    # Load user config
    _load_tld_config
    
    printf "%-8s %-25s %s\n" "TLD" "WHOIS Server" "Available Pattern"
    printf "%-8s %-25s %s\n" "---" "------------" "-----------------"
    
    # Show built-in and user-configured TLDs
    local tld server pattern
    for tld in "${!TLD_REGISTRY[@]}"; do
        IFS='|' read -r server pattern <<< "${TLD_REGISTRY[$tld]}"
        printf "%-8s %-25s %s\n" "$tld" "$server" "$pattern"
    done
    
    printf "\nUser configuration file: %s\n" "$WATCHDOM_RC"
    
    return 0
}

################################################################################
# do_add_tld - Add TLD configuration
################################################################################
do_add_tld() {
    local tld="$1"
    local server="$2"
    local pattern="$3"
    
    # Validate inputs
    if [[ -z "$tld" || -z "$server" || -z "$pattern" ]]; then
        error "Usage: add_tld TLD WHOIS_SERVER AVAILABLE_PATTERN"
        return 2
    fi
    
    # Ensure TLD starts with dot
    [[ "$tld" != .* ]] && tld=".$tld"
    
    # Add to user configuration
    echo "$tld|$server|$pattern" >> "$WATCHDOM_RC"
    
    okay "Added TLD configuration: %s -> %s | %s" "$tld" "$server" "$pattern"
    return 0
}

################################################################################
# do_test_tld - Test TLD configuration
################################################################################
do_test_tld() {
    local tld="$1"
    local test_domain="$2"
    
    if [[ -z "$tld" || -z "$test_domain" ]]; then
        error "Usage: test_tld TLD TEST_DOMAIN"
        return 2
    fi
    
    # Load configuration
    _load_tld_config
    
    # Get TLD configuration
    local config server pattern
    config=$(_get_tld_config "$test_domain")
    IFS='|' read -r server pattern <<< "$config"
    
    printf "\n%sTLD Test Results%s\n" "$blue" "$x"
    printf "TLD: %s\n" "$tld"
    printf "Test domain: %s\n" "$test_domain"
    printf "WHOIS server: %s\n" "${server:-default}"
    printf "Expected pattern: %s\n" "${pattern:-available}"
    
    # Execute test query
    local whois_output
    if whois_output=$(__whois_query "$test_domain"); then
        printf "\n%sPattern Match Test:%s\n" "$yellow" "$x"
        if echo "$whois_output" | grep -qi "${pattern:-available}"; then
            printf "%s%s Pattern MATCHED%s\n" "$green" "$pass" "$x"
            return 0
        else
            printf "%s%s Pattern NOT matched%s\n" "$red" "$fail" "$x"
            return 1
        fi
    else
        error "WHOIS query failed for test domain"
        return 3
    fi
}
# === 08_interface.sh ===
################################################################################
# interface - user interface with proper BashFX separation
################################################################################

################################################################################
# usage - Help documentation
################################################################################
usage() {
    cat <<'EOF'
watchdom - registry WHOIS watcher with phase-aware polling

USAGE:
  watchdom COMMAND [OPTIONS]

COMMANDS:
  query DOMAIN                     Single WHOIS lookup
  watch DOMAIN [OPTIONS]           Monitor domain with polling  
  time "DATETIME" [OPTIONS]        Countdown to target time
  list_tlds                        Show supported TLD configurations
  add_tld TLD SERVER PATTERN       Add custom TLD configuration
  test_tld TLD DOMAIN              Test TLD pattern matching
  install                          Install to system paths
  uninstall                        Remove from system paths
  status                           Show installation status

WATCH OPTIONS:
  -i SECONDS      Base polling interval (default: 60)
  -e PATTERN      Expected availability pattern (custom regex)
  -n MAX_CHECKS   Stop after N checks (default: unlimited)
  --until WHEN    Target datetime ("YYYY-MM-DD HH:MM:SS UTC" or epoch)
  --time-utc      Display times in UTC instead of local

GLOBAL OPTIONS:
  -d, --debug     Enable debug messages
  -t, --trace     Enable trace messages (verbose polling)
  -q, --quiet     Force quiet mode (errors only)
  -y, --yes       Auto-confirm prompts
  -h, --help      Show this help

EXAMPLES:
  watchdom query example.com
  watchdom watch example.com -i 30
  watchdom watch premium.com --until "2025-12-25 18:00:00 UTC" -i 10
  watchdom time "2025-12-25 18:00:00 UTC"
  watchdom add_tld .uk whois.nominet.uk "No such domain"

PHASE SYSTEM:
  λ POLL  - Normal polling intervals
  ▲ HEAT  - Aggressive polling as target approaches  
  ▵ GRACE - Post-target monitoring window
  ❅ COOL  - Backing off with longer intervals

EXIT CODES:
  0: Success (pattern matched/available)
  1: Not found (timeout/unavailable)
  2: Bad arguments
  3: Missing dependencies
  4: Date parse error
EOF
}

################################################################################
# options - Argument parsing (extracted from main for BashFX compliance)
################################################################################
options() {
    # Initialize option variables
    opt_debug=0
    opt_trace=0
    opt_quiet=0
    opt_yes=0
    opt_interval=""
    opt_expect=""
    opt_max_checks=""
    opt_until=""
    opt_time_utc=0
    
    # Parse all options, separating them from positional arguments
    local args=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            (-d|--debug) opt_debug=1; shift ;;
            (-t|--trace) opt_trace=1; opt_debug=1; shift ;;
            (-q|--quiet) opt_quiet=1; opt_debug=0; opt_trace=0; shift ;;
            (-y|--yes) opt_yes=1; shift ;;
            (-i)
                [[ $# -ge 2 ]] || { error "Option -i requires an argument"; return 2; }
                opt_interval="$2"; shift 2 ;;
            (-e)
                [[ $# -ge 2 ]] || { error "Option -e requires an argument"; return 2; }
                opt_expect="$2"; shift 2 ;;
            (-n)
                [[ $# -ge 2 ]] || { error "Option -n requires an argument"; return 2; }
                opt_max_checks="$2"; shift 2 ;;
            (--until)
                [[ $# -ge 2 ]] || { error "Option --until requires an argument"; return 2; }
                opt_until="$2"; shift 2 ;;
            (--time-utc|--utc) opt_time_utc=1; shift ;;
            (--time-local) opt_time_utc=0; shift ;;
            (-h|--help) usage; exit 0 ;;
            (--) shift; args+=("$@"); break ;;
            (-*) error "Unknown option: %s" "$1"; usage; return 2 ;;
            (*) args+=("$1"); shift ;;
        esac
    done
    
    # Restore positional arguments
    [[ ${#args[@]} -gt 0 ]] && set -- "${args[@]}"
    
    # Apply quiet mode override
    if [[ "$opt_quiet" -eq 1 ]]; then
        opt_debug=0
        opt_trace=0
    fi
    
    # Export parsed arguments
    export opt_debug opt_trace opt_quiet opt_yes opt_interval opt_expect opt_max_checks opt_until opt_time_utc
    
    # Return remaining arguments via global array
    remaining_args=("$@")
    return 0
}

################################################################################
# dispatch - Command routing (extracted from main for BashFX compliance)
################################################################################
dispatch() {
    local cmd="${1:-}"
    local ret=1
    
    # Validate command
    if [[ -z "$cmd" ]]; then
        error "No command specified"
        usage
        return 2
    fi
    
    # Route to command functions
    case "$cmd" in
        (query)
            [[ $# -ge 2 ]] || { error "Command 'query' requires a domain"; return 2; }
            shift
            do_query "$@"
            ret=$?
            ;;
        (watch)
            [[ $# -ge 2 ]] || { error "Command 'watch' requires a domain"; return 2; }
            shift
            do_watch "$@"
            ret=$?
            ;;
        (time)
            [[ $# -ge 2 ]] || { error "Command 'time' requires a datetime"; return 2; }
            shift
            do_time "$@"
            ret=$?
            ;;
        (list_tlds)
            do_list_tlds
            ret=$?
            ;;
        (add_tld)
            [[ $# -ge 4 ]] || { error "Command 'add_tld' requires TLD, server, and pattern"; return 2; }
            shift
            do_add_tld "$@"
            ret=$?
            ;;
        (test_tld)
            [[ $# -ge 3 ]] || { error "Command 'test_tld' requires TLD and test domain"; return 2; }
            shift
            do_test_tld "$@"
            ret=$?
            ;;
        (install)
            do_install
            ret=$?
            ;;
        (uninstall)
            do_uninstall  
            ret=$?
            ;;
        (status)
            do_status
            ret=$?
            ;;
        (*)
            error "Unknown command: %s" "$cmd"
            usage
            ret=2
            ;;
    esac
    
    return $ret
}

################################################################################
# main - Entry point (BashFX compliant: parse and dispatch only)
################################################################################
main() {
    local ret=1
    
    # Set up signal handling
    trap '_cleanup' INT TERM
    
    # Parse arguments
    local remaining_args=()
    if ! options "$@"; then
        return 2
    fi
    
    # Dispatch to command
    if [[ ${#remaining_args[@]} -gt 0 ]]; then
        dispatch "${remaining_args[@]}"
        ret=$?
    else
        error "No command specified"
        usage
        ret=2
    fi
    
    return $ret
}
# === 09_footer.sh ===
################################################################################
# installation commands (do_install, do_uninstall, do_status)
################################################################################

################################################################################
# do_install - Install to XDG+ compliant paths
################################################################################
do_install() {
    local ret=0
    
    # Create directories
    if ! mkdir -p "$FX_LIB_DIR" "$FX_BIN_DIR"; then
        error "Failed to create installation directories"
        return 1
    fi
    
    # Copy script to lib location
    if ! cp "$SELF_PATH" "$FX_INSTALL_PATH"; then
        error "Failed to copy script to %s" "$FX_INSTALL_PATH"
        return 1
    fi
    
    # Create symlink in bin
    if ! ln -sf "$FX_INSTALL_PATH" "$FX_BIN_LINK"; then
        error "Failed to create symlink at %s" "$FX_BIN_LINK"
        return 1
    fi
    
    okay "Installed %s to %s" "$SELF_NAME" "$FX_INSTALL_PATH"
    okay "Created symlink at %s" "$FX_BIN_LINK"
    
    # Check if bin directory is in PATH
    if [[ ":$PATH:" != *":$FX_BIN_DIR:"* ]]; then
        printf "\n%sIMPORTANT:%s Add to your shell profile:\n" "$yellow" "$x"
        printf "export PATH=\"%s:\$PATH\"\n\n" "$FX_BIN_DIR"
    fi
    
    return $ret
}

################################################################################
# do_uninstall - Remove installation
################################################################################
do_uninstall() {
    local ret=0
    local removed_items=0
    
    # Remove symlink
    if [[ -L "$FX_BIN_LINK" ]]; then
        if rm -f "$FX_BIN_LINK"; then
            okay "Removed symlink: %s" "$FX_BIN_LINK"
            removed_items=$((removed_items + 1))
        else
            error "Failed to remove symlink: %s" "$FX_BIN_LINK"
            ret=1
        fi
    fi
    
    # Remove script
    if [[ -f "$FX_INSTALL_PATH" ]]; then
        if rm -f "$FX_INSTALL_PATH"; then
            okay "Removed script: %s" "$FX_INSTALL_PATH"
            removed_items=$((removed_items + 1))
        else
            error "Failed to remove script: %s" "$FX_INSTALL_PATH"
            ret=1
        fi
    fi
    
    # Remove empty directories
    if [[ -d "$FX_LIB_DIR" ]] && [[ -z "$(ls -A "$FX_LIB_DIR" 2>/dev/null)" ]]; then
        if rmdir "$FX_LIB_DIR"; then
            trace "Removed empty directory: %s" "$FX_LIB_DIR"
        fi
    fi
    
    if [[ "$removed_items" -eq 0 ]]; then
        warn "%s was not installed or already removed" "$SELF_NAME"
        ret=1
    else
        okay "Successfully uninstalled %s (%d items removed)" "$SELF_NAME" "$removed_items"
        info "User configuration preserved at %s" "$WATCHDOM_RC"
    fi
    
    return $ret
}

################################################################################
# do_status - Show installation status
################################################################################
do_status() {
    local ret=0
    
    printf "%swatchdom v%s - Installation Status%s\n\n" "$blue" "$SELF_VERSION" "$x"
    
    printf "Current script: %s\n" "$SELF_PATH"
    
    if [[ -f "$FX_INSTALL_PATH" ]]; then
        printf "Installed at  : %s %s✓%s\n" "$FX_INSTALL_PATH" "$green" "$x"
    else
        printf "Installed at  : %s %s✗%s\n" "$FX_INSTALL_PATH" "$red" "$x"
        ret=1
    fi
    
    if [[ -L "$FX_BIN_LINK" ]]; then
        local link_target
        link_target="$(readlink "$FX_BIN_LINK")"
        printf "Symlink       : %s -> %s %s✓%s\n" "$FX_BIN_LINK" "$link_target" "$green" "$x"
    else
        printf "Symlink       : %s %s✗%s\n" "$FX_BIN_LINK" "$red" "$x"
        ret=1
    fi
    
    if [[ ":$PATH:" == *":$FX_BIN_DIR:"* ]]; then
        printf "PATH includes : %s %s✓%s\n" "$FX_BIN_DIR" "$green" "$x"
    else
        printf "PATH includes : %s %s✗%s\n" "$FX_BIN_DIR" "$red" "$x"
    fi
    
    if [[ -f "$WATCHDOM_RC" ]]; then
        local tld_count
        tld_count="$(grep -c '^[^#]' "$WATCHDOM_RC" 2>/dev/null || echo 0)"
        printf "User config   : %s (%s custom TLDs) %s✓%s\n" "$WATCHDOM_RC" "$tld_count" "$green" "$x"
    else
        printf "User config   : %s %s✗%s\n" "$WATCHDOM_RC" "$yellow" "$x"
    fi
    
    printf "\n"
    
    if [[ "$ret" -eq 0 ]]; then
        okay "watchdom is properly installed and ready to use"
    else
        warn "watchdom installation is incomplete - run 'watchdom install'"
    fi
    
    return $ret
}

################################################################################
# invocation and cleanup
################################################################################

# Signal handlers and cleanup
set -euo pipefail

# Global variables for cleanup
declare -a remaining_args=()

# Invoke main function
main "$@"
