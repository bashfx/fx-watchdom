#!/usr/bin/env bash
# build.sh - Assemble script from numbered modular parts

set -euo pipefail

# Colors for output
readonly green=$'\033[32m';
readonly blue=$'\033[34m';
readonly yellow=$'\033[33m';
readonly red=$'\033[31m';
readonly x=$'\033[38;5;244m';

# Configuration
PARTS_DIR="parts";
OUTPUT_FILE="watchdom_fixed.sh";
TEMPLATE_FILE="template.sh";

main() {
    printf "%sBuilding script from numbered modular parts%s\n" "$blue" "$x";
    printf "Parts directory: %s\n" "$PARTS_DIR";
    printf "Output file: %s\n\n" "$OUTPUT_FILE";
    
    # Verify parts directory exists
    if [[ ! -d "$PARTS_DIR" ]]; then
        printf "%sERROR:%s Parts directory '%s' not found\n" "$red" "$x" "$PARTS_DIR" >&2
        exit 1;
    fi
    
    # Auto-discover numbered modules in order
    local modules=()
    while IFS= read -r -d '' file; do
        local basename_file
        basename_file=$(basename "$file")
        # Check if file matches pattern: NN_*.sh (where NN is 2+ digits)
        if [[ "$basename_file" =~ ^[0-9]{2,}_.*\.sh$ ]]; then
            modules+=("$basename_file")
        fi
    done < <(find "$PARTS_DIR" -name "[0-9]*_*.sh" -print0 | sort -z)
    
    # Verify we found modules
    if [[ ${#modules[@]} -eq 0 ]]; then
        printf "%sERROR:%s No numbered modules found in %s\n" "$red" "$x" "$PARTS_DIR" >&2
        printf "Expected pattern: NN_name.sh (e.g., 01_header.sh, 02_colors.sh)\n" >&2
        exit 1
    fi
    
    printf "%sDiscovered %d modules:%s\n" "$green" "${#modules[@]}" "$x"
    for module in "${modules[@]}"; do
        local module_path="$PARTS_DIR/$module"
        if [[ -f "$module_path" ]]; then
            printf "%s✓%s %s\n" "$green" "$x" "$module"
        else
            printf "%s✗%s %s (missing)\n" "$red" "$x" "$module"
            exit 1
        fi
    done
    
    printf "\n%sAssembling modules in numeric order...%s\n" "$yellow" "$x"
    
    # Create header with generation info
    cat > "$OUTPUT_FILE" <<-EOF
			#!/usr/bin/env bash
			# Generated by build.sh on $(date)
			# Auto-assembled from numbered modules: ${modules[*]}
		EOF
    
    # Assemble modules in numeric order
    local first_module=true
    for module in "${modules[@]}"; do
        local module_path="$PARTS_DIR/$module"
        printf "  Adding: %s\n" "$module"
        
        # Add module separator comment
        echo "# === $module ===" >> "$OUTPUT_FILE"
        
        # Handle shebang: only include from first module
        if [[ "$first_module" == true ]]; then
            # Include everything from first module including shebang
            cat "$module_path" >> "$OUTPUT_FILE"
            first_module=false
        else
            # Skip shebang line from subsequent modules
            if head -1 "$module_path" | grep -q "^#!/"; then
                tail -n +2 "$module_path" >> "$OUTPUT_FILE"
            else
                # No shebang to skip
                cat "$module_path" >> "$OUTPUT_FILE"
            fi
        fi
        
        # Add spacing between modules
        echo "" >> "$OUTPUT_FILE"
    done
    
    # Make executable
    chmod +x "$OUTPUT_FILE"
    
    printf "\n%s✓ Successfully assembled:%s %s\n" "$green" "$x" "$OUTPUT_FILE"
    
    # Quick syntax check
    printf "%sPerforming syntax check...%s\n" "$yellow" "$x"
    if bash -n "$OUTPUT_FILE"; then
        printf "%s✓ Syntax check passed%s\n" "$green" "$x"
    else
        printf "%s✗ Syntax errors detected%s\n" "$red" "$x" >&2
        exit 1
    fi
    
    # Show file info
    local line_count word_count
    line_count=$(wc -l < "$OUTPUT_FILE")
    word_count=$(wc -w < "$OUTPUT_FILE")
    
    printf "\n%sGenerated script info:%s\n" "$blue" "$x"
    printf "  Modules: %d\n" "${#modules[@]}"
    printf "  Lines: %s\n" "$line_count"
    printf "  Words: %s\n" "$word_count"
    printf "  Size: %s bytes\n" "$(wc -c < "$OUTPUT_FILE")"
    
    printf "\n%sReady for testing:%s\n" "$blue" "$x"
    printf "  Basic test: ./%s --help\n" "$OUTPUT_FILE"
    printf "  Syntax: bash -n %s\n" "$OUTPUT_FILE"
    
    printf "\n%s✓ Build complete!%s\n" "$green" "$x"
}

# Help function
usage() {
    cat << EOF
build.sh - Assemble script from numbered modular parts

USAGE:
  ./build.sh [OPTIONS]

OPTIONS:
  -h, --help    Show this help
  -o FILE       Output file (default: watchdom_fixed.sh)
  -p DIR        Parts directory (default: parts)
  -v            Verbose mode
  -c            Clean (remove output file before building)
  -l            List discovered modules and exit

EXAMPLES:
  ./build.sh                           # Build with defaults
  ./build.sh -o watchdom.sh            # Custom output name
  ./build.sh -p modules -o watchdom    # Custom parts dir and output
  ./build.sh -c                        # Clean build
  ./build.sh -l                        # List modules only

MODULE NAMING:
  Modules must follow pattern: NN_name.sh
  Where NN is 2+ digit number (e.g., 01, 02, 99, 100)
  
  Examples:
    01_header.sh     ✓ Valid
    02_colors.sh     ✓ Valid
    99_footer.sh     ✓ Valid
    100_extra.sh     ✓ Valid
    1_bad.sh         ✗ Invalid (single digit)
    header.sh        ✗ Invalid (no number)
    01_header.txt    ✗ Invalid (not .sh)

DIRECTORY STRUCTURE:
  ./
  ├── build.sh              # This script
  └── parts/                # Module directory
      ├── 01_header.sh
      ├── 02_colors.sh
      ├── ...
      └── NN_footer.sh
EOF
}

# Parse arguments
list_only=false
while [[ $# -gt 0 ]]; do
    case "$1" in
        (-h|--help)
            usage
            exit 0
            ;;
        (-o)
            [[ $# -ge 2 ]] || { echo "ERROR: -o requires an argument" >&2; exit 1; }
            OUTPUT_FILE="$2"
            shift 2
            ;;
        (-p)
            [[ $# -ge 2 ]] || { echo "ERROR: -p requires an argument" >&2; exit 1; }
            PARTS_DIR="$2"
            shift 2
            ;;
        (-c)
            if [[ -f "$OUTPUT_FILE" ]]; then
                printf "%sCleaning:%s Removing existing %s\n" "$yellow" "$x" "$OUTPUT_FILE"
                rm -f "$OUTPUT_FILE"
            fi
            shift
            ;;
        (-l)
            list_only=true
            shift
            ;;
        (-v)
            set -x
            shift
            ;;
        (*)
            printf "%sERROR:%s Unknown option: %s\n" "$red" "$x" "$1" >&2
            usage >&2
            exit 1
            ;;
    esac
done

# List mode: just show discovered modules
if [[ "$list_only" == true ]]; then
    printf "%sDiscovering numbered modules in %s:%s\n\n" "$blue" "$PARTS_DIR" "$x"
    
    if [[ ! -d "$PARTS_DIR" ]]; then
        printf "%sERROR:%s Directory '%s' not found\n" "$red" "$x" "$PARTS_DIR" >&2
        exit 1
    fi
    
    local modules=()
    while IFS= read -r -d '' file; do
        local basename_file
        basename_file=$(basename "$file")
        if [[ "$basename_file" =~ ^[0-9]{2,}_.*\.sh$ ]]; then
            modules+=("$basename_file")
        fi
    done < <(find "$PARTS_DIR" -name "[0-9]*_*.sh" -print0 | sort -z)
    
    if [[ ${#modules[@]} -eq 0 ]]; then
        printf "%sNo numbered modules found%s\n" "$yellow" "$x"
        printf "Expected pattern: NN_name.sh\n"
        exit 1
    fi
    
    printf "%sFound %d modules:%s\n" "$green" "${#modules[@]}" "$x"
    for i in "${!modules[@]}"; do
        printf "%3d. %s\n" $((i+1)) "${modules[$i]}"
    done
    
    exit 0
fi

main "$@"
